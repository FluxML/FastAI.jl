{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"Flux/layers/show.jl","docid":"Flux@0.13.17/src/layers/show.jl"},{"tag":"sourcefile","title":"Flux/layers/basic.jl","docid":"Flux@0.13.17/src/layers/basic.jl"}],"methods":[{"symbol_id":"Flux.EmbeddingBag","module_id":"Flux","file":"layers/basic.jl","line":849,"signature":"(::Signature)"},{"symbol_id":"Flux.EmbeddingBag","module_id":"Flux","file":"layers/basic.jl","line":848,"signature":"(::Signature)"},{"symbol_id":"Flux.EmbeddingBag","module_id":"Flux","file":"layers/basic.jl","line":842,"signature":"(::Signature)"}],"package_id":"Flux@0.13.17","title":"EmbeddingBag","symbol_id":"Flux.EmbeddingBag","exported":false,"module_id":"Flux"},"tag":"documentation","children":[{"attributes":{"symbol":"Flux.EmbeddingBag","line":749,"module":"Flux","file":"layers/basic.jl"},"tag":"docstring","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["EmbeddingBag(in => out, reduction=mean; init=Flux.randn32)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["A lookup table that stores embeddings of dimension ",{"attributes":{},"tag":"code","children":["out"],"type":"node"}," for a vocabulary of size ",{"attributes":{},"tag":"code","children":["in"],"type":"node"},". Differs from ",{"attributes":{"reftype":"symbol","href":"@ref","title":"","document_id":"Flux@0.13.17/ref/Flux.Embedding"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["Embedding"],"type":"node"}],"type":"node"}," in that, instead of acting on a single vocabulary index, it always acts a vector of indices which it calls a \"bag\". Their individual embedding vectors are reduced to one, using ",{"attributes":{},"tag":"code","children":["mean"],"type":"node"}," or some other function."],"type":"node"},{"attributes":{},"tag":"p","children":["Instead of acting on one \"bag\", such as ",{"attributes":{},"tag":"code","children":["x::Vector{Int}"],"type":"node"},", the layer can also act on several:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Acting on a vector of \"bags\", it produces a matrix whose columns are the reduced vectors. More generally on ",{"attributes":{},"tag":"code","children":["x::Array{Vector{Int}}"],"type":"node"},", its output is of size ",{"attributes":{},"tag":"code","children":["(out, size(x)...)"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Any higher-rank array of integers is interpreted as a collection of \"bags\" each along the first dimension. Thus the output is ",{"attributes":{},"tag":"code","children":["mapslices(e, x; dims=1)"],"type":"node"}," when ",{"attributes":{},"tag":"code","children":["e::EmbeddingBag"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["x::Array{Int,N}"],"type":"node"},". This method is more efficient, but requires that all \"bags\" have the same length."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["A vector of \"bags\" may also be produced by splitting a vector of indices at specified points. For this case the layer takes two inputs, both vectors of integers. See details below."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["The \"bag\" may equivalently be represented as a ",{"attributes":{},"tag":"code","children":["OneHotMatrix"],"type":"node"},". A collection of these, or one higher-rank ",{"attributes":{},"tag":"code","children":["OneHotArray"],"type":"node"},", again produce a stack of embeddings. See details below."],"type":"node"},{"attributes":{},"tag":"h1","children":["Examples"],"type":"node"},{"attributes":{"lang":"jldoctest"},"tag":"codeblock","children":["julia> vocab_size = 26;  # embed into 3 dimensions, with non-random vectors:\n\njulia> eb = EmbeddingBag(vocab_size => 3, init=Flux.identity_init(gain=100))\nEmbeddingBag(26 => 3)  # 78 parameters\n\njulia> eb([2])  # one bag of 1 item\n3-element Vector{Float32}:\n   0.0\n 100.0\n   0.0\n\njulia> eb([3,3,1])  # one bag of 3 items, one mean embedding\n3-element Vector{Float32}:\n 33.333332\n  0.0\n 66.666664\n\njulia> eb([[3,1,3], [2,1]])  # two bags\n3×2 Matrix{Float32}:\n 33.3333  50.0\n  0.0     50.0\n 66.6667   0.0\n\njulia> eb([1 1 1 1; 1 2 3 4])  # 4 bags each of 2 items, eachcol([1 1 1 1; 1 2 3 4])\n3×4 Matrix{Float32}:\n 100.0  50.0  50.0  50.0\n   0.0  50.0   0.0   0.0\n   0.0   0.0  50.0   0.0\n\njulia> eb(rand(1:26, 10, 5, 5)) |> size  # 25 bags each of 10 items\n(3, 5, 5)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Another way to specify \"many bags of many items\" is to provide a vector ",{"attributes":{},"tag":"code","children":["data"],"type":"node"}," (each in ",{"attributes":{},"tag":"code","children":["1:in"],"type":"node"},") and a vector ",{"attributes":{},"tag":"code","children":["at"],"type":"node"}," stating where to split that up into \"bags\". The first bag starts with ",{"attributes":{},"tag":"code","children":["data[at[1]]"],"type":"node"},", the second at ",{"attributes":{},"tag":"code","children":["data[at[2]]"],"type":"node"},", and so on, with no overlaps and nothing left out (thus it requires ",{"attributes":{},"tag":"code","children":["at[1]==1"],"type":"node"},")."],"type":"node"},{"attributes":{"lang":"jldoctest"},"tag":"codeblock","children":["julia> data = [11, 1, 12, 2, 13, 3, 14];\n\njulia> Flux._splitat(data, [1, 4]) |> println  # internal function, makes data[1:3], data[4:end]\n[[11, 1, 12], [2, 13, 3, 14]]\n\njulia> eb(data, [1, 4])  # two bags, of 3 and 4 items\n3×2 Matrix{Float32}:\n 33.3333   0.0\n  0.0     25.0\n  0.0     25.0\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Finally, each bag may also be also be represented as a [",{"attributes":{},"tag":"code","children":["OneHotMatrix"],"type":"node"},"](",{"attributes":{"id":"ref"},"tag":"citation","children":[],"type":"node"}," OneHotArrays.onehotbatch)."],"type":"node"},{"attributes":{"lang":"jldoctest"},"tag":"codeblock","children":["julia> eb(Flux.onehotbatch(\"bba\", 'a':'z'))  # same as [2,2,1], one bag of 3 items\n3-element Vector{Float32}:\n 33.333332\n 66.666664\n  0.0\n\njulia> eb([Flux.onehotbatch(\"bba\", 'a':'z'), Flux.onehotbatch(\"cc\", 'a':'z')])  # two bags\n3×2 Matrix{Float32}:\n 33.3333    0.0\n 66.6667    0.0\n  0.0     100.0\n"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}