{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"FastVision/models.jl","docid":"FastVision@0.1.0/src/models.jl"},{"tag":"sourcefile","title":"FastVision/models/unet.jl","docid":"FastVision@0.1.0/src/models/unet.jl"},{"tag":"sourcefile","title":"Flux/deprecations.jl","docid":"Flux@0.13.9/src/deprecations.jl"},{"tag":"sourcefile","title":"Flux/outputsize.jl","docid":"Flux@0.13.9/src/outputsize.jl"},{"tag":"documentation","title":"DiscriminativeLRs","docid":"FastAI@pr-273/ref/FastAI.DiscriminativeLRs"},{"tag":"sourcefile","title":"FastAI/training/paramgroups.jl","docid":"FastAI@pr-273/src/training/paramgroups.jl"},{"tag":"sourcefile","title":"Flux/layers/show.jl","docid":"Flux@0.13.9/src/layers/show.jl"},{"tag":"sourcefile","title":"Flux/Flux.jl","docid":"Flux@0.13.9/src/Flux.jl"},{"tag":"sourcefile","title":"FastVision/models/xresnet.jl","docid":"FastVision@0.1.0/src/models/xresnet.jl"},{"tag":"sourcefile","title":"Flux/layers/basic.jl","docid":"Flux@0.13.9/src/layers/basic.jl"},{"tag":"sourcefile","title":"FastAI/training/discriminativelrs.jl","docid":"FastAI@pr-273/src/training/discriminativelrs.jl"},{"tag":"document","title":"Variational autoencoders","docid":"FastAI@pr-273/doc/docs/notebooks/vae.ipynb"},{"tag":"sourcefile","title":"FastVision/models/blocks.jl","docid":"FastVision@0.1.0/src/models/blocks.jl"},{"tag":"sourcefile","title":"FastAI/training/finetune.jl","docid":"FastAI@pr-273/src/training/finetune.jl"},{"tag":"document","title":"Custom learning tasks","docid":"FastAI@pr-273/doc/docs/learning_methods.md"},{"tag":"document","title":"Keypoint regression","docid":"FastAI@pr-273/doc/docs/notebooks/keypointregression.ipynb"},{"tag":"documentation","title":"loadmodel!","docid":"Flux@0.13.9/ref/Flux.loadmodel!"},{"tag":"documentation","title":"Parallel","docid":"Flux@0.13.9/ref/Flux.Parallel"},{"tag":"documentation","title":"ParamGroups","docid":"FastAI@pr-273/ref/FastAI.ParamGroups"}],"methods":[{"symbol_id":"Flux.Chain","module_id":"Flux","file":"layers/basic.jl","line":40,"signature":"(::Signature)"},{"symbol_id":"Flux.Chain","module_id":"Flux","file":"layers/basic.jl","line":36,"signature":"(::Signature)"},{"symbol_id":"Flux.Chain","module_id":"Flux","file":"layers/basic.jl","line":39,"signature":"(::Signature)"}],"package_id":"Flux@0.13.9","title":"Chain","symbol_id":"Flux.Chain","exported":true,"module_id":"Flux"},"tag":"documentation","children":[{"attributes":{"symbol":"Flux.Chain","line":1,"module":"Flux","file":"layers/basic.jl"},"tag":"docstring","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["Chain(layers...)\nChain(name = layer, ...)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Collects multiple layers / functions to be called in sequence on a given input. Supports indexing and slicing, ",{"attributes":{},"tag":"code","children":["m[2]"],"type":"node"}," or ",{"attributes":{},"tag":"code","children":["m[1:end-1]"],"type":"node"},", and if names are given, ",{"attributes":{},"tag":"code","children":["m[:name] == m[1]"],"type":"node"}," etc."],"type":"node"},{"attributes":{},"tag":"h1","children":["Examples"],"type":"node"},{"attributes":{"lang":"jldoctest"},"tag":"codeblock","children":["julia> m = Chain(x -> x^2, x -> x+1);\n\njulia> m(5) == 26\ntrue\n\njulia> m = Chain(Dense(10 => 5, tanh), Dense(5 => 2));\n\njulia> x = rand(10, 32);\n\njulia> m(x) == m[2](m[1](x))\ntrue\n\njulia> m2 = Chain(enc = Chain(Flux.flatten, Dense(10 => 5, tanh)), \n                  dec = Dense(5 => 2));\n\njulia> m2(x) == (m2[:dec] âˆ˜ m2[:enc])(x)\ntrue\n"],"type":"node"},{"attributes":{},"tag":"p","children":["For large models, there is a special type-unstable path which can reduce compilation times. This can be used by supplying a vector of layers ",{"attributes":{},"tag":"code","children":["Chain([layer1, layer2, ...])"],"type":"node"},". This feature is somewhat experimental, beware!"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}