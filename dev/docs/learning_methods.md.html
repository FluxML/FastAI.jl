<HTML><head><title>Custom learning methods</title><script src=../template/highlight.min.js ></script><script src=../template/julia.min.js ></script><script src=../template/loadhighlightjs.js ></script><link href=../template/ansi.css rel=stylesheet ></link><link href=../template/hugobook.css rel=stylesheet ></link><meta content=Type=text/html; charset=utf-8 http-equiv=Content-Type ></meta><meta name=viewport content=width=device-width, initial-scale=1 ></meta></head><body><input onclick=toggleMenu() id=menu-control class=hidden toggle type=checkbox ></input><input id=toc-control type=checkbox class=hidden toggle ></input><main class=container flex ><aside id=menu-container class=book-menu ><nav class=book-menu-content ><h2 id=title >FastAI.jl</h2><div id=sidebar ><div class=doctree ><body><ul><li><p><a href=../README.md.html title= >README</a></p></li><li><p><a href=setup.md.html title= >Setup</a></p></li><li><p><a href=../notebooks/quickstart.ipynb.html title= >Quickstart</a></p></li><li><p>Tutorials</p><ul><li><p>Beginner</p><ul><li><p><a href=introduction.md.html title= >Introduction</a></p></li><li><p><a href=discovery.md.html title= >Discovery</a></p></li></ul></li><li><p>Intermediate</p><ul><li><p><a href=../notebooks/imagesegmentation.ipynb.html title= >Image segmentation</a></p></li><li><p><a href=../notebooks/keypointregression.ipynb.html title= >Keypoint regression</a></p></li><li><p><a href=../notebooks/tabularclassification.ipynb.html title= >Tabular classification</a></p></li><li><p><a href=data_containers.md.html title= >Data containers</a></p></li><li><p><a href=../notebooks/serialization.ipynb.html title= >Saving and loading models</a></p></li></ul></li><li><p>Advanced</p><ul><li><p><a href=../notebooks/presizing.ipynb.html title= >Presizing vision datasets</a></p></li><li><p><a href=learning_methods.md.html title= >Custom Learning methods</a></p></li></ul></li></ul></li><li><p>How To</p><ul><li><p><a href=../notebooks/training.ipynb.html title= >Train your model</a></p></li><li><p><a href=howto/augmentvision.md.html title= >Augment vision data</a></p></li><li><p><a href=../notebooks/how_to_visualize.ipynb.html title= >Visualize data</a></p></li><li><p><a href=howto/logtensorboard.md.html title= >Log to TensorBoard</a></p></li></ul></li><li><p>Reference</p><ul><li><p><a href=../REFERENCE.html title= >Docstrings</a></p></li><li><p><a href=fastai_api_comparison.md.html title= >fastai API comparison</a></p></li><li><p><a href=interfaces.md.html title= >Extension APIs</a></p></li><li><p><a href=glossary.md.html title= >Glossary</a></p></li></ul></li><li><p>Background</p><ul><li><p><a href=background/blocksencodings.md.html title= >Blocks and encodings</a></p></li><li><p><a href=background/datapipelines.md.html title= >Performant data pipelines</a></p></li></ul></li></ul></body></div></div></nav></aside><div class=book-page ><header class=book-header ></header><article><h1 id=custom-learning-methods >Custom learning methods</h1><p><em>This tutorial explains the low-level interface behind <code>BlockMethod</code>s and how to use it to create your custom learning methods without the data block interface.</em></p><p>In the <a href=./quickstart.md.html title= >quickstart</a> section, you’ve already seen a learning method in action: <a href=../REFERENCE/FastAI.BlockMethod.html ><code>BlockMethod</code></a>. The learning method abstraction powers FastAI.jl’s high-level interface allowing you to make training models for a task simple. <code>BlockMethod</code> is a particularly convenient and composable interface for creating learning methods and should be preferred for most use cases.</p><p>However, to get a look behind the scenes, in this tutorial we’ll use the lower-level learning method interface to implement our own version of an image classification learning method. You’re encouraged to follow along in a REPL or notebook. This tutorial can also serve as a template for implementing a custom learning method for your own project.</p><p>A learning method describes how we need to process data so we can train a model for some task. In our case, the task we want to solve is to classify an image. The task defines what kind of data we need, here pairs of images and class labels. That alone, however, isn’t enough to train a model since we can’t just throw an image in any format into a model and get a class out. Almost always the input data needs to be processed in some way before it is input to a model (we call this <strong>encoding</strong>) and the same goes for the model outputs (we call this <strong>decoding</strong>).</p><p>So let’s say we have an image and a trained model. How do we make a prediction? First we encode the image, run it through the model, and then decode the output. Similarly, how we can use a pair of image and class to train a model? We encode both, run the encoded input through the model and then compare the output with the encoded class using a <strong>loss function</strong>. The result tells us how we’ll need to update the weights of the model to improve its performance.</p><p>In essence, the learning method interface allows us to implement these steps and derive useful functionality from it, like training and evaluating models. Later we’ll also cover some optional interfaces that allow us to define other parts of a deep learning project.</p><h2 id=datasets >Datasets</h2><p>Before we get started, let’s load up a <a href=./data_containers.md.html title= >data container</a> that we can test our code on as we go. It’s always a good idea to interactively test your code! Since we’ll be implementing a method for image classification, the observations in our data container will of course have to be pairs of images and classes. We’ll use one of the many image classification datasets available from the fastai dataset repository. I’ll use ImageNette, but you can use any of the datasets listed in <code>FastAI.Datasets.DATASETS_IMAGECLASSIFICATION</code>. The way the interface is built allows you to easily swap out the dataset you’re using.</p><div class=cellcontainer cell=main lang=julia ><pre class=codecell cell=main lang=julia ><code>using FastAI, FastAI.DataAugmentation, FastAI.DLPipelines, FastAI.Colors
data = Datasets.loadfolderdata(
    datasetpath(&quot;imagenette2-160&quot;),
    filterfn=isimagefile,
    loadfn=(loadfile, parentname))
</code></pre><pre class=coderesult ><code>(mapobs(loadfile, ["/home/runner/.julia/datadeps/fastai-imagenette2-160/imagenette2-160/train/n014…]), mapobs(parentname, ["/home/runner/.julia/datadeps/fastai-imagenette2-160/imagenette2-160/train/n014…]))</code></pre></div><p>We’ll also collect the unique class names:</p><div class=cellcontainer cell=main lang=julia ><pre class=codecell cell=main lang=julia ><code>images, targets = data
classes = unique(eachobs(targets))
</code></pre><pre class=coderesult ><code>10-element Vector{String}:
 "n01440764"
 "n02102040"
 "n02979186"
 "n03000684"
 "n03028079"
 "n03394916"
 "n03417042"
 "n03425413"
 "n03445777"
 "n03888257"</code></pre></div><h2 id=implementation >Implementation</h2><h3 id=learning-method-struct >Learning method struct</h3><p>Now let’s get to it! The first thing we need to do is to create a <a href=../REFERENCE/DLPipelines.LearningMethod.html ><code>LearningMethod</code></a> struct. The <code>LearningMethod</code> <code>struct</code> should contain all the configuration needed for encoding and decoding the data. We’ll keep it simple here and include a list of the classes and the image dimensions input to the model.</p><div class=cellcontainer cell=main lang=julia ><pre class=codecell cell=main lang=julia ><code>using FastAI: DLPipelines

struct ImageClassification &lt;: DLPipelines.LearningMethod
    classes
    size
end
</code></pre></div><p>Now we can create an instance of it, though of course it can’t do anything (yet!).</p><div result=true class=cellcontainer cell=main lang=julia ><pre result=true class=codecell cell=main lang=julia ><code>method = ImageClassification(classes, (128, 128))
</code></pre><pre class=coderesult ><code>Main.docslearningmethodsmd_main.ImageClassification(["n01440764", "n02102040", "n02979186", "n03000684", "n03028079", "n03394916", "n03417042", "n03425413", "n03445777", "n03888257"], (128, 128))</code></pre></div><h3 id=encoding-and-decoding >Encoding and decoding</h3><p>There are 3 methods we need to define before we can use our learning method to train models and make predictions:</p><ul><li><p><a href=../REFERENCE/DLPipelines.encode.html ><code>encode</code></a> which encodes an image and a class</p></li><li><p><a href=../REFERENCE/DLPipelines.encodeinput.html ><code>encodeinput</code></a> will encode an image so it can be input to a model</p></li><li><p><a href=../REFERENCE/DLPipelines.decodeŷ.html ><code>decodeŷ</code></a> (write <code>\hat&lt;TAB&gt;</code> for  <code> ̂</code>) decodes a model output into a class label</p></li></ul><p>Note: These functions always operate on <em>single</em> images and classes, even if we want to pass batches to the model later on.</p><p>While it’s not the focus of this tutorial, let’s give a quick recap of how the data is encoded and decoded for image classification.</p><ul><li><p>Images are cropped to a common size so they can be batched, converted to a 3D array with dimensions (height, width, color channels) and normalized</p></li><li><p>Classes are encoded as one-hot vectors, teaching the model to predict a confidence distribution over all classes. To decode a predicted one-hot vector, we can simply find the index with the highest value and look up the class label.</p></li></ul><p>Each of the methods also takes a <code>context::</code><a href=../REFERENCE/DLPipelines.Context.html ><code>Context</code></a> argument which allows it to behave differently during training, validation and inference. We’ll make use of that to choose a different image crop for each situation. During training we’ll use a random crop for augmentation, while during validation a center crop will ensure that any metrics we track are the same every epoch. During inference, we won’t crop the image so we don’t lose any information.</p><h4 id=inputs >Inputs</h4><p>We implement <a href=../REFERENCE/DLPipelines.encodeinput.html ><code>encodeinput</code></a> using <a href=https://github.com/lorenzoh/DataAugmentation.jl title= >DataAugmentation.jl</a>. Feel free to look at <a href=https://lorenzoh.github.io/DataAugmentation.jl/dev/docs/literate/intro.html title= >its documentation</a>, we won’t focus on it here.</p><div class=cellcontainer cell=main lang=julia ><pre class=codecell cell=main lang=julia ><code>using FastAI: IMAGENET_MEANS, IMAGENET_STDS  # color statistics for normalization

# Helper for crop based on context
getresizecrop(context::Training, sz) = DataAugmentation.RandomResizeCrop(sz)
getresizecrop(context::Validation, sz) = CenterResizeCrop(sz)
getresizecrop(context::Inference, sz) = ResizePadDivisible(sz, 32)

function DLPipelines.encodeinput(
        method::ImageClassification,
        context::Context,
        image)
    tfm = DataAugmentation.compose(
        getresizecrop(context, method.size),
        ToEltype(RGB{Float32}),
        ImageToTensor(),
        Normalize(IMAGENET_MEANS, IMAGENET_STDS);
    )
    return apply(tfm, DataAugmentation.Image(image)) |&gt; itemdata
end
</code></pre></div><p>If we test this out on an image, it should give us a 3D array of size <code>(128, 128, 3)</code>, and indeed it does:</p><div class=cellcontainer cell=main lang=julia ><pre class=codecell cell=main lang=julia ><code>sample = image, class = getobs(data, 1)
x = encodeinput(method, Training(), image)
summary(x)
</code></pre><pre class=coderesult ><code>128×128×3 Array{Float32, 3}</code></pre></div><h4 id=outputs >Outputs</h4><p><code>encodetarget</code> is much simpler:</p><div class=cellcontainer cell=main lang=julia ><pre class=codecell cell=main lang=julia ><code>function DLPipelines.encodetarget(
        method::ImageClassification,
        ::Context,
        class)
    idx = findfirst(isequal(class), method.classes)
    v = zeros(Float32, length(method.classes))
    v[idx] = 1.
    return v
end

DLPipelines.encode(method::ImageClassification, ctx, (input, target)) = (
    encodeinput(method, ctx, input),
    encodetarget(method, ctx, target),
)


</code></pre></div><div class=cellcontainer cell=main lang=julia ><pre class=codecell cell=main lang=julia ><code>y = encodetarget(method, Training(), class)
</code></pre><pre class=coderesult ><code>10-element Vector{Float32}:
 1.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0</code></pre></div><p>The same goes for the decoding step:</p><div class=cellcontainer cell=main lang=julia ><pre class=codecell cell=main lang=julia ><code>function DLPipelines.decodeŷ(method::ImageClassification, ::Context, ŷ)
    return method.classes[argmax(ŷ)]
end
</code></pre></div><div class=cellcontainer cell=main lang=julia ><pre class=codecell cell=main lang=julia ><code>decodeŷ(method, Training(), y) == class
</code></pre><pre class=coderesult ><code>true</code></pre></div><h2 id=training >Training</h2><p>And that’s all we need to start training models! There are some optional interfaces that make that even easier, but let’s use what we have for now.</p><p>With our <code>LearningMethod</code> defined, we can use <a href=../REFERENCE/DLPipelines.methoddataloaders.html ><code>DLPipelines.methoddataloaders</code></a> to turn a dataset into a set of training and validation data loaders that can be thrown into a training loop.</p><div class=cellcontainer cell=main lang=julia ><pre class=codecell cell=main lang=julia ><code>traindl, valdl = methoddataloaders(data, method)
</code></pre><pre class=coderesult ><code>(eachobsparallel(batchviewcollated() with 670 batches of size 16), eachobsparallel(batchviewcollated() with 84 batches of size 32))</code></pre></div><p>Now, with a makeshift model, an optimizer and a loss function we can create a <a href=../REFERENCE/FluxTraining.Learner.html ><code>Learner</code></a>.</p><div class=cellcontainer cell=main lang=julia ><pre class=codecell cell=main lang=julia ><code>using FastAI: Flux

model = Chain(
    Models.xresnet18(),
    Chain(
            AdaptiveMeanPool((1,1)),
            flatten,
            Dense(512, length(method.classes)),
    )
)
opt = ADAM()
lossfn = Flux.Losses.logitcrossentropy

learner = Learner(model, (traindl, valdl), opt, lossfn)
</code></pre><pre class=coderesult ><code>Learner()</code></pre></div><p>From here, you’re free to start training using  <a href=../REFERENCE/FluxTraining.fit!.html ><code>fit!</code></a> or <a href=../REFERENCE/FastAI.fitonecycle!.html ><code>fitonecycle!</code></a>.</p><p>These methods are also enough to use <a href=../REFERENCE/DLPipelines.predict.html ><code>DLPipelines.predict</code></a> and <a href=../REFERENCE/DLPipelines.predictbatch.html ><code>DLPipelines.predictbatch</code></a> once you’ve trained a model.</p><h2 id=additional-interfaces >Additional interfaces</h2><h3 id=training-interface >Training interface</h3><p>We can implement some additional methods to make our life easier. Specifically, let’s implement every method needed to use <a href=../REFERENCE/FastAI.methodlearner.html ><code>methodlearner</code></a>:</p><ul><li><p><a href=../REFERENCE/DLPipelines.methodlossfn.html ><code>DLPipelines.methodlossfn</code></a>: return a loss function <code>lossfn(ys, ys)</code> comparing a batch of model outputs and encoded targets</p></li><li><p><a href=../REFERENCE/DLPipelines.methodmodel.html ><code>DLPipelines.methodmodel</code></a>: from a backbone, construct a model suitable for the task</p></li></ul><p>Let’s start with the loss function. We want to compare two one-hot encoded categorical variables, for which categorical cross entropy is the most commonly used loss function.</p><pre cell=main lang= ><code>DLPipelines.methodlossfn(method::ImageClassification) = Flux.Losses.logitcrossentropy
</code></pre><p>For the model, we’ll assume we’re getting a convolutional feature extractor passed in as a backbone so its output will be of size (height, width, channels, batch size). <a href=../REFERENCE/Flux.outputsize.html ><code>Flux.outputsize</code></a> can be used to calculate the output size of arbitrary models without having to evaluate the model. We’ll use it to check the number of output channels of the backbone. Then we add a global pooling layer and some dense layers on top to get a classification output.</p><div class=cellcontainer cell=main lang=julia ><pre class=codecell cell=main lang=julia ><code>function DLPipelines.methodmodel(method::ImageClassification, backbone)
    h, w, outch, b = Flux.outputsize(backbone, (256, 256, inblock.nchannels, 1))
    head = Chain(
        AdaptiveMeanPool((1, 1)),
        Dense(outch, 512),
        BatchNorm(512),
        Dense(512, length(method.classes))
    )
    return Chain(backbone, head)
end
</code></pre></div></article><footer class=book-footer ></footer></div><aside class=book-toc ><nav id=toc class=book-toc-content ><ul><li><a href=#custom-learning-methods >Custom learning methods</a><ul><li><a href=#datasets >Datasets</a><ul></ul></li><li><a href=#implementation >Implementation</a><ul><li><a href=#learning-method-struct >Learning method struct</a><ul></ul></li><li><a href=#encoding-and-decoding >Encoding and decoding</a><ul><li><a href=#inputs >Inputs</a></li><li><a href=#outputs >Outputs</a></li></ul></li></ul></li><li><a href=#training >Training</a><ul></ul></li><li><a href=#additional-interfaces >Additional interfaces</a><ul><li><a href=#training-interface >Training interface</a><ul></ul></li></ul></li></ul></li></ul></nav></aside></main></body></HTML>