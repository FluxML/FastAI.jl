{"attributes":{"kind":"struct","backlinks":[{"tag":"documentation","title":"ParamGroups","docid":"references/FastAI.ParamGroups"},{"tag":"sourcefile","title":"Flux/src/layers/basic.jl","docid":"sourcefiles/Flux/src/layers/basic.jl"},{"tag":"sourcefile","title":"FastAI/src/Tabular/Tabular.jl","docid":"sourcefiles/FastAI/src/Tabular/Tabular.jl"},{"tag":"sourcefile","title":"Flux/src/Flux.jl","docid":"sourcefiles/Flux/src/Flux.jl"},{"tag":"document","title":"Variational autoencoders","docid":"documents/notebooks/vae.ipynb"},{"tag":"sourcefile","title":"Flux/src/layers/show.jl","docid":"sourcefiles/Flux/src/layers/show.jl"},{"tag":"sourcefile","title":"FastAI/src/Vision/models/unet.jl","docid":"sourcefiles/FastAI/src/Vision/models/unet.jl"},{"tag":"document","title":"Keypoint regression","docid":"documents/notebooks/keypointregression.ipynb"},{"tag":"sourcefile","title":"FastAI/src/Tabular/models.jl","docid":"sourcefiles/FastAI/src/Tabular/models.jl"},{"tag":"document","title":"Custom learning tasks","docid":"documents/docs/learning_methods.md"},{"tag":"documentation","title":"BatchNorm","docid":"references/Flux.BatchNorm"},{"tag":"sourcefile","title":"FastAI/src/Vision/models.jl","docid":"sourcefiles/FastAI/src/Vision/models.jl"},{"tag":"sourcefile","title":"Flux/src/outputsize.jl","docid":"sourcefiles/Flux/src/outputsize.jl"},{"tag":"sourcefile","title":"FastAI/src/Vision/models/xresnet.jl","docid":"sourcefiles/FastAI/src/Vision/models/xresnet.jl"},{"tag":"sourcefile","title":"FastAI/src/training/finetune.jl","docid":"sourcefiles/FastAI/src/training/finetune.jl"},{"tag":"sourcefile","title":"FastAI/src/training/paramgroups.jl","docid":"sourcefiles/FastAI/src/training/paramgroups.jl"},{"tag":"sourcefile","title":"FastAI/src/Vision/models/blocks.jl","docid":"sourcefiles/FastAI/src/Vision/models/blocks.jl"},{"tag":"documentation","title":"loadmodel!","docid":"references/Flux.loadmodel!"},{"tag":"sourcefile","title":"FastAI/src/training/discriminativelrs.jl","docid":"sourcefiles/FastAI/src/training/discriminativelrs.jl"},{"tag":"documentation","title":"DiscriminativeLRs","docid":"references/FastAI.DiscriminativeLRs"}],"methods":[{"line":40,"file":"/home/runner/.julia/packages/Flux/18YZE/src/layers/basic.jl","method_id":"Flux.Chain_1","symbol_id":"Flux.Chain","signature":"Chain(; kw...)"},{"line":36,"file":"/home/runner/.julia/packages/Flux/18YZE/src/layers/basic.jl","method_id":"Flux.Chain_2","symbol_id":"Flux.Chain","signature":"Chain(layers::T)"},{"line":39,"file":"/home/runner/.julia/packages/Flux/18YZE/src/layers/basic.jl","method_id":"Flux.Chain_3","symbol_id":"Flux.Chain","signature":"Chain(xs...)"}],"name":"Chain","title":"Chain","symbol_id":"Flux.Chain","public":true,"module_id":"Flux"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["Chain(layers...)\nChain(name = layer, ...)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Collects multiple layers / functions to be called in sequence",{"attributes":{},"tag":"br","children":[],"type":"node"},"on a given input. Supports indexing and slicing, ",{"attributes":{},"tag":"code","children":["m[2]"],"type":"node"}," or ",{"attributes":{},"tag":"code","children":["m[1:end-1]"],"type":"node"},",",{"attributes":{},"tag":"br","children":[],"type":"node"},"and if names are given, ",{"attributes":{},"tag":"code","children":["m[:name] == m[1]"],"type":"node"}," etc."],"type":"node"},{"attributes":{},"tag":"h1","children":["Examples"],"type":"node"},{"attributes":{"lang":"jldoctest"},"tag":"codeblock","children":["julia> m = Chain(x -> x^2, x -> x+1);\n\njulia> m(5) == 26\ntrue\n\njulia> m = Chain(Dense(10 => 5, tanh), Dense(5 => 2));\n\njulia> x = rand(10, 32);\n\njulia> m(x) == m[2](m[1](x))\ntrue\n\njulia> m2 = Chain(enc = Chain(Flux.flatten, Dense(10 => 5, tanh)), \n                  dec = Dense(5 => 2));\n\njulia> m2(x) == (m2[:dec] âˆ˜ m2[:enc])(x)\ntrue\n"],"type":"node"},{"attributes":{},"tag":"p","children":["For large models, there is a special type-unstable path which can reduce compilation",{"attributes":{},"tag":"br","children":[],"type":"node"},"times. This can be used by supplying a vector of layers ",{"attributes":{},"tag":"code","children":["Chain([layer1, layer2, ...])"],"type":"node"},".",{"attributes":{},"tag":"br","children":[],"type":"node"},"This feature is somewhat experimental, beware!"],"type":"node"}],"type":"node"}],"type":"node"}