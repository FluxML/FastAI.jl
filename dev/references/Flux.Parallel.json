{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"Flux/src/layers/basic.jl","docid":"sourcefiles/Flux/src/layers/basic.jl"},{"tag":"sourcefile","title":"FastAI/src/Tabular/Tabular.jl","docid":"sourcefiles/FastAI/src/Tabular/Tabular.jl"},{"tag":"sourcefile","title":"FastAI/src/Vision/models/layers.jl","docid":"sourcefiles/FastAI/src/Vision/models/layers.jl"},{"tag":"sourcefile","title":"Flux/src/Flux.jl","docid":"sourcefiles/Flux/src/Flux.jl"},{"tag":"document","title":"Variational autoencoders","docid":"documents/notebooks/vae.ipynb"},{"tag":"sourcefile","title":"Flux/src/layers/show.jl","docid":"sourcefiles/Flux/src/layers/show.jl"},{"tag":"sourcefile","title":"FastAI/src/Vision/models/unet.jl","docid":"sourcefiles/FastAI/src/Vision/models/unet.jl"},{"tag":"sourcefile","title":"FastAI/src/Tabular/models.jl","docid":"sourcefiles/FastAI/src/Tabular/models.jl"}],"methods":[{"line":488,"file":"/home/runner/.julia/packages/Flux/js6mP/src/layers/basic.jl","method_id":"Flux.Parallel_1","symbol_id":"Flux.Parallel","filedoc":"sourcefiles/Flux/src/layers/basic.jl","signature":"Parallel(connection; kw...)"},{"line":483,"file":"/home/runner/.julia/packages/Flux/js6mP/src/layers/basic.jl","method_id":"Flux.Parallel_2","symbol_id":"Flux.Parallel","filedoc":"sourcefiles/Flux/src/layers/basic.jl","signature":"Parallel(connection::F, layers::T)"},{"line":487,"file":"/home/runner/.julia/packages/Flux/js6mP/src/layers/basic.jl","method_id":"Flux.Parallel_3","symbol_id":"Flux.Parallel","filedoc":"sourcefiles/Flux/src/layers/basic.jl","signature":"Parallel(connection, layers...)"}],"name":"Parallel","title":"Parallel","symbol_id":"Flux.Parallel","public":true,"module_id":"Flux"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["Parallel(connection, layers...)\nParallel(connection; name = layer, ...)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Create a layer which passes an input array to each path in ",{"attributes":{},"tag":"code","children":["layers"],"type":"node"},", before reducing the output with ",{"attributes":{},"tag":"code","children":["connection"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["Called with one input ",{"attributes":{},"tag":"code","children":["x"],"type":"node"},", this is equivalent to ",{"attributes":{},"tag":"code","children":["connection([l(x) for l in layers]...)"],"type":"node"},". If called with multiple inputs, one is passed to each layer, thus ",{"attributes":{},"tag":"code","children":["Parallel(+, f, g)(x, y) = f(x) + g(y)"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["Like ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"references/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["Chain"],"type":"node"}],"type":"node"},", its sub-layers may be given names using the keyword constructor. These can be accessed by indexing: ",{"attributes":{},"tag":"code","children":["m[1] == m[:name]"],"type":"node"}," is the first layer."],"type":"node"},{"attributes":{},"tag":"p","children":["See also ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"references/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["SkipConnection"],"type":"node"}],"type":"node"}," which is ",{"attributes":{},"tag":"code","children":["Parallel"],"type":"node"}," with one ",{"attributes":{},"tag":"code","children":["identity"],"type":"node"},", and ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"references/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["Maxout"],"type":"node"}],"type":"node"}," which reduces by broadcasting ",{"attributes":{},"tag":"code","children":["max"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"h1","children":["Examples"],"type":"node"},{"attributes":{"lang":"jldoctest"},"tag":"codeblock","children":["julia> model = Chain(Dense(3 => 5),\n                     Parallel(vcat, Dense(5 => 4), Chain(Dense(5 => 7), Dense(7 => 4))),\n                     Dense(8 => 17));\n\njulia> model(rand(3)) |> size\n(17,)\n\njulia> model2 = Parallel(+; α = Dense(10, 2, tanh), β = Dense(5, 2))\nParallel(\n  +,\n  α = Dense(10 => 2, tanh),             # 22 parameters\n  β = Dense(5 => 2),                    # 12 parameters\n)                   # Total: 4 arrays, 34 parameters, 392 bytes.\n\njulia> model2(rand(10), rand(5)) |> size\n(2,)\n\njulia> model2[:α](rand(10)) |> size\n(2,)\n\njulia> model2[:β] == model2[2]\ntrue\n"],"type":"node"}],"type":"node"}],"type":"node"}