{"attributes":{"kind":"function","backlinks":[{"tag":"sourcefile","title":"Flux/src/utils.jl","docid":"sourcefiles/Flux/src/utils.jl"}],"methods":[{"line":455,"file":"/home/runner/.julia/packages/Flux/18YZE/src/utils.jl","method_id":"Flux.identity_init_1","symbol_id":"Flux.identity_init","signature":"identity_init()"},{"line":437,"file":"/home/runner/.julia/packages/Flux/18YZE/src/utils.jl","method_id":"Flux.identity_init_2","symbol_id":"Flux.identity_init","signature":"identity_init(cols::Integer; gain, shift)"},{"line":440,"file":"/home/runner/.julia/packages/Flux/18YZE/src/utils.jl","method_id":"Flux.identity_init_3","symbol_id":"Flux.identity_init","signature":"identity_init(rows::Integer, cols::Integer; gain, shift)"},{"line":455,"file":"/home/runner/.julia/packages/Flux/18YZE/src/utils.jl","method_id":"Flux.identity_init_4","symbol_id":"Flux.identity_init","signature":"identity_init(rng::Random.AbstractRNG; init_kwargs...)"},{"line":454,"file":"/home/runner/.julia/packages/Flux/18YZE/src/utils.jl","method_id":"Flux.identity_init_5","symbol_id":"Flux.identity_init","signature":"identity_init(::Random.AbstractRNG, dims::Integer...; kwargs...)"},{"line":443,"file":"/home/runner/.julia/packages/Flux/18YZE/src/utils.jl","method_id":"Flux.identity_init_6","symbol_id":"Flux.identity_init","signature":"identity_init(dims::Integer...; gain, shift)"}],"name":"identity_init","title":"identity_init","symbol_id":"Flux.identity_init","public":false,"module_id":"Flux"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["identity_init(size...; gain=1, shift=0) -> Array\nidentity_init(; kw...) -> Function\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Return an ",{"attributes":{},"tag":"code","children":["Array{Float32}"],"type":"node"}," of the given ",{"attributes":{},"tag":"code","children":["size"],"type":"node"}," which yields an identity mapping when used as parameters in",{"attributes":{},"tag":"br","children":[],"type":"node"},"most Flux layers. Use ",{"attributes":{},"tag":"code","children":["gain"],"type":"node"}," to scale the identity by a constant."],"type":"node"},{"attributes":{},"tag":"p","children":["Often useful in the context of transfer learning, i.e when one wants to add more capacity to",{"attributes":{},"tag":"br","children":[],"type":"node"},"a model but start from the same mapping."],"type":"node"},{"attributes":{},"tag":"p","children":["Has the following behaviour"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["1D: A ",{"attributes":{},"tag":"code","children":["Vector"],"type":"node"}," of ",{"attributes":{},"tag":"code","children":["zeros"],"type":"node"}," (useful for an identity bias)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["2D: An identity matrix (useful for an identity matrix multiplication)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["More than 2D: A dense block array of center tap spatial filters (useful for an identity convolution)"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Some caveats:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Not all layers will be identity mapping when used with this init. Exceptions",{"attributes":{},"tag":"br","children":[],"type":"node"},"include recurrent layers and normalization layers."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Layers must have ",{"attributes":{},"tag":"code","children":["input_size == output_size"],"type":"node"}," for identity mapping to be",{"attributes":{},"tag":"br","children":[],"type":"node"},"possible. When this is not the case, extra dimensions of the array are padded with zeros."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["For convolutional layers, in addition to the above, the kernel sizes must also be odd and",{"attributes":{},"tag":"br","children":[],"type":"node"},"padding must be applied so that output feature maps have the same size as input feature maps,",{"attributes":{},"tag":"br","children":[],"type":"node"},"e.g by using ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"references/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["SamePad"],"type":"node"}],"type":"node"},"."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Use keyword ",{"attributes":{},"tag":"code","children":["shift"],"type":"node"}," (integer or tuple) to apply circular shift to the output,",{"attributes":{},"tag":"br","children":[],"type":"node"},"equivalent to ",{"attributes":{},"tag":"code","children":["Base.circshift(identity_init(size...), shift)"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["For consistency with other initialisers, it accepts ",{"attributes":{},"tag":"code","children":["rng::AbstractRNG"],"type":"node"}," as an optional",{"attributes":{},"tag":"br","children":[],"type":"node"},"first argument. But this is ignored, since the result is not random."],"type":"node"},{"attributes":{},"tag":"h1","children":["Examples"],"type":"node"},{"attributes":{"lang":"jldoctest"},"tag":"codeblock","children":["julia> Flux.identity_init(3,5)\n3×5 Matrix{Float32}:\n 1.0  0.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0\n\njulia> Dense(5 => 3, relu, init=Flux.identity_init)([1,-2,3,-4,5])\n3-element Vector{Float32}:\n 1.0\n 0.0\n 3.0\n\njulia> Flux.identity_init(3,3,2; gain=100)\n3×3×2 Array{Float32, 3}:\n[:, :, 1] =\n   0.0  0.0  0.0\n 100.0  0.0  0.0\n   0.0  0.0  0.0\n\n[:, :, 2] =\n 0.0    0.0  0.0\n 0.0  100.0  0.0\n 0.0    0.0  0.0\n\njulia> x4 = cat([1 2 3; 4 5 6; 7 8 9]; dims=4);\n\njulia> Conv((2,2), 1 => 1, init=Flux.identity_init(gain=10), pad=SamePad())(x4)\n3×3×1×1 Array{Float32, 4}:\n[:, :, 1, 1] =\n 10.0  20.0  30.0\n 40.0  50.0  60.0\n 70.0  80.0  90.0\n"],"type":"node"}],"type":"node"}],"type":"node"}