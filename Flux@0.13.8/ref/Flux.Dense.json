{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"Flux/layers/show.jl","docid":"Flux@0.13.8/src/layers/show.jl"},{"tag":"sourcefile","title":"Flux/deprecations.jl","docid":"Flux@0.13.8/src/deprecations.jl"},{"tag":"sourcefile","title":"FastAI/training/discriminativelrs.jl","docid":"FastAI@dev/src/training/discriminativelrs.jl"},{"tag":"documentation","title":"DiscriminativeLRs","docid":"FastAI@dev/ref/FastAI.DiscriminativeLRs"},{"tag":"sourcefile","title":"FastAI/training/paramgroups.jl","docid":"FastAI@dev/src/training/paramgroups.jl"},{"tag":"documentation","title":"Bilinear","docid":"Flux@0.13.8/ref/Flux.Bilinear"},{"tag":"document","title":"Custom learning tasks","docid":"FastAI@dev/doc/docs/learning_methods.md"},{"tag":"documentation","title":"Scale","docid":"Flux@0.13.8/ref/Flux.Scale"},{"tag":"sourcefile","title":"Flux/Flux.jl","docid":"Flux@0.13.8/src/Flux.jl"},{"tag":"sourcefile","title":"Flux/outputsize.jl","docid":"Flux@0.13.8/src/outputsize.jl"},{"tag":"documentation","title":"ParamGroups","docid":"FastAI@dev/ref/FastAI.ParamGroups"},{"tag":"documentation","title":"loadmodel!","docid":"Flux@0.13.8/ref/Flux.loadmodel!"},{"tag":"sourcefile","title":"FastVision/models/blocks.jl","docid":"FastVision@0.1.0/src/models/blocks.jl"},{"tag":"document","title":"Variational autoencoders","docid":"FastAI@dev/doc/docs/notebooks/vae.ipynb"},{"tag":"sourcefile","title":"Flux/layers/basic.jl","docid":"Flux@0.13.8/src/layers/basic.jl"}],"methods":[{"symbol_id":"Flux.Dense","module_id":"Flux","file":"deprecations.jl","line":63,"signature":"(::Signature)"},{"symbol_id":"Flux.Dense","module_id":"Flux","file":"layers/basic.jl","line":163,"signature":"(::Signature)"},{"symbol_id":"Flux.Dense","module_id":"Flux","file":"layers/basic.jl","line":157,"signature":"(::Signature)"}],"package_id":"Flux@0.13.8","title":"Dense","symbol_id":"Flux.Dense","exported":true,"module_id":"Flux"},"tag":"documentation","children":[{"attributes":{"symbol":"Flux.Dense","line":112,"module":"Flux","file":"layers/basic.jl"},"tag":"docstring","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["Dense(in => out, σ=identity; bias=true, init=glorot_uniform)\nDense(W::AbstractMatrix, [bias, σ])\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Create a traditional fully connected layer, whose forward pass is given by:"],"type":"node"},{"attributes":{"lang":""},"tag":"codeblock","children":["y = σ.(W * x .+ bias)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["The input ",{"attributes":{},"tag":"code","children":["x"],"type":"node"}," should be a vector of length ",{"attributes":{},"tag":"code","children":["in"],"type":"node"},", or batch of vectors represented as an ",{"attributes":{},"tag":"code","children":["in × N"],"type":"node"}," matrix, or any array with ",{"attributes":{},"tag":"code","children":["size(x,1) == in"],"type":"node"},". The out ",{"attributes":{},"tag":"code","children":["y"],"type":"node"}," will be a vector  of length ",{"attributes":{},"tag":"code","children":["out"],"type":"node"},", or a batch with ",{"attributes":{},"tag":"code","children":["size(y) == (out, size(x)[2:end]...)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Keyword ",{"attributes":{},"tag":"code","children":["bias=false"],"type":"node"}," will switch off trainable bias for the layer. The initialisation of the weight matrix is ",{"attributes":{},"tag":"code","children":["W = init(out, in)"],"type":"node"},", calling the function given to keyword ",{"attributes":{},"tag":"code","children":["init"],"type":"node"},", with default [",{"attributes":{},"tag":"code","children":["glorot_uniform"],"type":"node"},"](",{"attributes":{},"tag":"citation","children":[],"type":"node"}," Flux.glorot_uniform). The weight matrix and/or the bias vector (of length ",{"attributes":{},"tag":"code","children":["out"],"type":"node"},") may also be provided explicitly."],"type":"node"},{"attributes":{},"tag":"h1","children":["Examples"],"type":"node"},{"attributes":{"lang":"jldoctest"},"tag":"codeblock","children":["julia> d = Dense(5 => 2)\nDense(5 => 2)       # 12 parameters\n\njulia> d(rand(Float32, 5, 64)) |> size\n(2, 64)\n\njulia> d(rand(Float32, 5, 1, 1, 64)) |> size  # treated as three batch dimensions\n(2, 1, 1, 64)\n\njulia> d1 = Dense(ones(2, 5), false, tanh)  # using provided weight matrix\nDense(5 => 2, tanh; bias=false)  # 10 parameters\n\njulia> d1(ones(5))\n2-element Vector{Float64}:\n 0.9999092042625951\n 0.9999092042625951\n\njulia> Flux.params(d1)  # no trainable bias\nParams([[1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0]])\n"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}