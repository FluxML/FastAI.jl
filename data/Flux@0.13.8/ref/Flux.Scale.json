{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"Flux/layers/show.jl","docid":"Flux@0.13.8/src/layers/show.jl"},{"tag":"sourcefile","title":"Flux/deprecations.jl","docid":"Flux@0.13.8/src/deprecations.jl"},{"tag":"sourcefile","title":"Flux/layers/normalise.jl","docid":"Flux@0.13.8/src/layers/normalise.jl"},{"tag":"documentation","title":"LayerNorm","docid":"Flux@0.13.8/ref/Flux.LayerNorm"},{"tag":"sourcefile","title":"Flux/layers/basic.jl","docid":"Flux@0.13.8/src/layers/basic.jl"}],"methods":[{"symbol_id":"Flux.Scale","module_id":"Flux","file":"layers/basic.jl","line":236,"signature":"(::Signature)"},{"symbol_id":"Flux.Scale","module_id":"Flux","file":"layers/basic.jl","line":230,"signature":"(::Signature)"},{"symbol_id":"Flux.Scale","module_id":"Flux","file":"layers/basic.jl","line":237,"signature":"(::Signature)"}],"package_id":"Flux@0.13.8","title":"Scale","symbol_id":"Flux.Scale","exported":false,"module_id":"Flux"},"tag":"documentation","children":[{"attributes":{"symbol":"Flux.Scale","line":185,"module":"Flux","file":"layers/basic.jl"},"tag":"docstring","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["Scale(size::Integer..., σ=identity; bias=true, init=ones32)\nScale(scale::AbstractArray, [bias, σ])\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Create an element-wise layer, whose forward pass is given by:"],"type":"node"},{"attributes":{"lang":""},"tag":"codeblock","children":["y = σ.(scale .* x .+ bias)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["This uses ",{"attributes":{},"tag":"code","children":[".*"],"type":"node"}," instead of matrix multiplication ",{"attributes":{},"tag":"code","children":["*"],"type":"node"}," of ",{"attributes":{"reftype":"symbol","href":"@ref","title":"","document_id":"Flux@0.13.8/ref/Flux.Dense"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["Dense"],"type":"node"}],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["The learnable scale & bias are initialised ",{"attributes":{},"tag":"code","children":["init(size...)"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["zeros32(size...)"],"type":"node"},", with ",{"attributes":{},"tag":"code","children":["init=ones32"],"type":"node"}," by default. You may specify the function ",{"attributes":{},"tag":"code","children":["init"],"type":"node"},", turn off trainable bias with ",{"attributes":{},"tag":"code","children":["bias=false"],"type":"node"},", or provide the array(s) explicitly."],"type":"node"},{"attributes":{},"tag":"p","children":["Used by ",{"attributes":{"reftype":"symbol","href":"@ref","title":"","document_id":"Flux@0.13.8/ref/Flux.LayerNorm"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["LayerNorm"],"type":"node"}],"type":"node"}," with ",{"attributes":{},"tag":"code","children":["affine=true"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"h1","children":["Examples"],"type":"node"},{"attributes":{"lang":"jldoctest"},"tag":"codeblock","children":["julia> a = Flux.Scale(2)\nScale(2)            # 4 parameters\n\njulia> Flux.params(a)\nParams([Float32[1.0, 1.0], Float32[0.0, 0.0]])\n\njulia> a([1 2 3])\n2×3 Matrix{Float32}:\n 1.0  2.0  3.0\n 1.0  2.0  3.0\n\njulia> b = Flux.Scale([1 2 3 4], false, abs2)\nScale(1, 4, abs2; bias=false)  # 4 parameters\n\njulia> b([1, 10])\n2×4 Matrix{Int64}:\n   1    4    9    16\n 100  400  900  1600\n\njulia> Flux.params(b)\nParams([[1 2 3 4]])\n"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}