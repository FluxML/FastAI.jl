{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"Flux/layers/show.jl","docid":"Flux@0.13.8/src/layers/show.jl"},{"tag":"sourcefile","title":"Flux/deprecations.jl","docid":"Flux@0.13.8/src/deprecations.jl"},{"tag":"documentation","title":"RNN","docid":"Flux@0.13.8/ref/Flux.RNN"},{"tag":"sourcefile","title":"Flux/layers/recurrent.jl","docid":"Flux@0.13.8/src/layers/recurrent.jl"}],"methods":[{"symbol_id":"Flux.Recur","module_id":"Flux","file":"layers/recurrent.jl","line":499,"signature":"(::Signature)"},{"symbol_id":"Flux.Recur","module_id":"Flux","file":"layers/recurrent.jl","line":431,"signature":"(::Signature)"},{"symbol_id":"Flux.Recur","module_id":"Flux","file":"layers/recurrent.jl","line":359,"signature":"(::Signature)"},{"symbol_id":"Flux.Recur","module_id":"Flux","file":"layers/recurrent.jl","line":288,"signature":"(::Signature)"},{"symbol_id":"Flux.Recur","module_id":"Flux","file":"layers/recurrent.jl","line":129,"signature":"(::Signature)"}],"package_id":"Flux@0.13.8","title":"Recur","symbol_id":"Flux.Recur","exported":false,"module_id":"Flux"},"tag":"documentation","children":[{"attributes":{"symbol":"Flux.Recur","line":56,"module":"Flux","file":"layers/recurrent.jl"},"tag":"docstring","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["Recur(cell)\n"],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["Recur"],"type":"node"}," takes a recurrent cell and makes it stateful, managing the hidden state in the background. ",{"attributes":{},"tag":"code","children":["cell"],"type":"node"}," should be a model of the form:"],"type":"node"},{"attributes":{"lang":""},"tag":"codeblock","children":["h, y = cell(h, x...)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["For example, here's a recurrent network that keeps a running total of its inputs:"],"type":"node"},{"attributes":{},"tag":"h1","children":["Examples"],"type":"node"},{"attributes":{"lang":"jldoctest"},"tag":"codeblock","children":["julia> accum(h, x) = (h + x, x)\naccum (generic function with 1 method)\n\njulia> rnn = Flux.Recur(accum, 0)\nRecur(accum)\n\njulia> rnn(2) \n2\n\njulia> rnn(3)\n3\n\njulia> rnn.state\n5\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Folding over a 3d Array of dimensions ",{"attributes":{},"tag":"code","children":["(features, batch, time)"],"type":"node"}," is also supported:"],"type":"node"},{"attributes":{"lang":"jldoctest"},"tag":"codeblock","children":["julia> accum(h, x) = (h .+ x, x)\naccum (generic function with 1 method)\n\njulia> rnn = Flux.Recur(accum, zeros(Int, 1, 1))\nRecur(accum)\n\njulia> rnn([2])\n1-element Vector{Int64}:\n 2\n\njulia> rnn([3])\n1-element Vector{Int64}:\n 3\n\njulia> rnn.state\n1×1 Matrix{Int64}:\n 5\n\njulia> out = rnn(reshape(1:10, 1, 1, :));  # apply to a sequence of (features, batch, time)\n\njulia> out |> size\n(1, 1, 10)\n\njulia> vec(out)\n10-element Vector{Int64}:\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n\njulia> rnn.state\n1×1 Matrix{Int64}:\n 60\n"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}