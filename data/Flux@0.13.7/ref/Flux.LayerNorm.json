{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"Flux/layers/normalise.jl","docid":"Flux@0.13.7/src/layers/normalise.jl"},{"tag":"documentation","title":"hasaffine","docid":"Flux@0.13.7/ref/Flux.hasaffine"},{"tag":"documentation","title":"Scale","docid":"Flux@0.13.7/ref/Flux.Scale"},{"tag":"sourcefile","title":"Flux/Flux.jl","docid":"Flux@0.13.7/src/Flux.jl"},{"tag":"sourcefile","title":"Flux/layers/show.jl","docid":"Flux@0.13.7/src/layers/show.jl"},{"tag":"sourcefile","title":"Flux/outputsize.jl","docid":"Flux@0.13.7/src/outputsize.jl"}],"methods":[{"symbol_id":"Flux.LayerNorm","module_id":"Flux","file":"layers/normalise.jl","line":220,"signature":"(::Signature)"},{"symbol_id":"Flux.LayerNorm","module_id":"Flux","file":"layers/normalise.jl","line":213,"signature":"(::Signature)"},{"symbol_id":"Flux.LayerNorm","module_id":"Flux","file":"layers/normalise.jl","line":224,"signature":"(::Signature)"},{"symbol_id":"Flux.LayerNorm","module_id":"Flux","file":"layers/normalise.jl","line":225,"signature":"(::Signature)"}],"package_id":"Flux@0.13.7","title":"LayerNorm","symbol_id":"Flux.LayerNorm","exported":true,"module_id":"Flux"},"tag":"documentation","children":[{"attributes":{"symbol":"Flux.LayerNorm","line":181,"module":"Flux","file":"layers/normalise.jl"},"tag":"docstring","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["LayerNorm(size..., λ=identity; affine=true, ϵ=1fe-5)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["A ",{"attributes":{"href":"https://arxiv.org/abs/1607.06450","title":""},"tag":"a","children":["normalisation layer"],"type":"node"}," designed to be used with recurrent hidden states. The argument ",{"attributes":{},"tag":"code","children":["size"],"type":"node"}," should be an integer or a tuple of integers. In the forward pass, the layer normalises the mean and standard deviation of the input, then applies the elementwise activation ",{"attributes":{},"tag":"code","children":["λ"],"type":"node"},". The input is normalised along the first ",{"attributes":{},"tag":"code","children":["length(size)"],"type":"node"}," dimensions for tuple ",{"attributes":{},"tag":"code","children":["size"],"type":"node"},", and along the first dimension for integer ",{"attributes":{},"tag":"code","children":["size"],"type":"node"},". The input is expected to have first dimensions' size equal to ",{"attributes":{},"tag":"code","children":["size"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["If ",{"attributes":{},"tag":"code","children":["affine=true"],"type":"node"},", it also applies a learnable shift and rescaling using the ",{"attributes":{"reftype":"symbol","href":"@ref","title":"","document_id":"Flux@0.13.7/ref/Flux.Scale"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["Scale"],"type":"node"}],"type":"node"}," layer."],"type":"node"},{"attributes":{},"tag":"p","children":["See also ",{"attributes":{"reftype":"symbol","href":"@ref","title":"","document_id":"Flux@0.13.7/ref/Flux.BatchNorm"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["BatchNorm"],"type":"node"}],"type":"node"},", ",{"attributes":{"reftype":"symbol","href":"@ref","title":"","document_id":"Flux@0.13.7/ref/Flux.InstanceNorm"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["InstanceNorm"],"type":"node"}],"type":"node"},", ",{"attributes":{"reftype":"symbol","href":"@ref","title":"","document_id":"Flux@0.13.7/ref/Flux.GroupNorm"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["GroupNorm"],"type":"node"}],"type":"node"},", and ",{"attributes":{"reftype":"symbol","href":"@ref","title":"","document_id":"Flux@0.13.7/ref/Flux.normalise"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["normalise"],"type":"node"}],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"h1","children":["Examples"],"type":"node"},{"attributes":{"lang":"jldoctest"},"tag":"codeblock","children":["julia> using Statistics\n\njulia> xs = rand(3, 3, 3, 2);  # a batch of 2 images, each having 3 channels\n\njulia> m = LayerNorm(3);\n\njulia> y = m(xs);\n\njulia> isapprox(std(y, dims=1:3), ones(1, 1, 1, 2), atol=0.1) && std(y, dims=1:3) != std(xs, dims=1:3)\ntrue\n"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}