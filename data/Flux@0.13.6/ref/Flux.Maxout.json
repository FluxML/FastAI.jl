{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"Flux/Flux.jl","docid":"Flux@0.13.6/src/Flux.jl"},{"tag":"documentation","title":"Parallel","docid":"Flux@0.13.6/ref/Flux.Parallel"},{"tag":"sourcefile","title":"Flux/layers/show.jl","docid":"Flux@0.13.6/src/layers/show.jl"},{"tag":"documentation","title":"SkipConnection","docid":"Flux@0.13.6/ref/Flux.SkipConnection"},{"tag":"sourcefile","title":"Flux/layers/basic.jl","docid":"Flux@0.13.6/src/layers/basic.jl"}],"methods":[{"symbol_id":"Flux.Maxout","module_id":"Flux","file":"layers/basic.jl","line":292,"signature":"(::Signature)"},{"symbol_id":"Flux.Maxout","module_id":"Flux","file":"layers/basic.jl","line":289,"signature":"(::Signature)"},{"symbol_id":"Flux.Maxout","module_id":"Flux","file":"layers/basic.jl","line":291,"signature":"(::Signature)"}],"package_id":"Flux@0.13.6","title":"Maxout","symbol_id":"Flux.Maxout","exported":true,"module_id":"Flux"},"tag":"documentation","children":[{"attributes":{"symbol":"Flux.Maxout","line":253,"module":"Flux","file":"layers/basic.jl"},"tag":"docstring","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["Maxout(layers...)\nMaxout(f, n_alts)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["This contains a number of internal layers, each of which receives the same input. Its output is the elementwise maximum of the the internal layers' outputs."],"type":"node"},{"attributes":{},"tag":"p","children":["Instead of defining layers individually, you can provide a zero-argument function which constructs them, and the number to construct."],"type":"node"},{"attributes":{},"tag":"p","children":["Maxout over linear dense layers satisfies the univeral approximation theorem. See Goodfellow, Warde-Farley, Mirza, Courville & Bengio \"Maxout Networks\" ",{"attributes":{"href":"https://arxiv.org/abs/1302.4389","title":""},"tag":"a","children":["https://arxiv.org/abs/1302.4389"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["See also ",{"attributes":{"reftype":"symbol","href":"@ref","title":"","document_id":"Flux@0.13.6/ref/Flux.Parallel"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["Parallel"],"type":"node"}],"type":"node"}," to reduce with other operators."],"type":"node"},{"attributes":{},"tag":"h1","children":["Examples"],"type":"node"},{"attributes":{"lang":"jldoctest"},"tag":"codeblock","children":["julia> m = Maxout(x -> abs2.(x), x -> x .* 3);\n\njulia> m([-2 -1 0 1 2])\n1Ã—5 Matrix{Int64}:\n 4  1  0  3  6\n\njulia> m3 = Maxout(() -> Dense(5 => 7, tanh), 3)\nMaxout(\n  Dense(5 => 7, tanh),                  # 42 parameters\n  Dense(5 => 7, tanh),                  # 42 parameters\n  Dense(5 => 7, tanh),                  # 42 parameters\n)                   # Total: 6 arrays, 126 parameters, 888 bytes.\n\njulia> Flux.outputsize(m3, (5, 11))\n(7, 11)\n"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}