{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"Flux/deprecations.jl","docid":"Flux@0.13.6/src/deprecations.jl"},{"tag":"sourcefile","title":"Flux/layers/show.jl","docid":"Flux@0.13.6/src/layers/show.jl"},{"tag":"sourcefile","title":"Flux/layers/basic.jl","docid":"Flux@0.13.6/src/layers/basic.jl"}],"methods":[{"symbol_id":"Flux.Embedding","module_id":"Flux","file":"deprecations.jl","line":67,"signature":"(::Signature)"},{"symbol_id":"Flux.Embedding","module_id":"Flux","file":"layers/basic.jl","line":681,"signature":"(::Signature)"},{"symbol_id":"Flux.Embedding","module_id":"Flux","file":"layers/basic.jl","line":676,"signature":"(::Signature)"}],"package_id":"Flux@0.13.6","title":"Embedding","symbol_id":"Flux.Embedding","exported":false,"module_id":"Flux"},"tag":"documentation","children":[{"attributes":{"symbol":"Flux.Embedding","line":646,"module":"Flux","file":"layers/basic.jl"},"tag":"docstring","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["Embedding(in => out; init=randn)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["A lookup table that stores embeddings of dimension ",{"attributes":{},"tag":"code","children":["out"],"type":"node"}," for a vocabulary of size ",{"attributes":{},"tag":"code","children":["in"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["This layer is often used to store word embeddings and retrieve them using indices. The input to the layer can be either a vector of indexes or the corresponding [",{"attributes":{},"tag":"code","children":["onehot encoding"],"type":"node"},"](",{"attributes":{},"tag":"citation","children":[],"type":"node"}," OneHotArrays.onehotbatch)."],"type":"node"},{"attributes":{},"tag":"h1","children":["Examples"],"type":"node"},{"attributes":{"lang":"jldoctest"},"tag":"codeblock","children":["julia> vocab_size, embed_size = 1000, 4;\n\njulia> model = Flux.Embedding(vocab_size => embed_size)\nEmbedding(1000 => 4)  # 4_000 parameters\n\njulia> vocab_idxs = [1, 722, 53, 220, 3];\n\njulia> x = Flux.onehotbatch(vocab_idxs, 1:vocab_size); summary(x)\n\"1000×5 OneHotMatrix(::Vector{UInt32}) with eltype Bool\"\n\njulia> model(x) |> summary\n\"4×5 Matrix{Float32}\"\n\njulia> model(vocab_idxs) == model(x)\ntrue\n"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}