{"attributes":{"kind":"function","backlinks":[{"tag":"documentation","title":"loadmodel!","docid":"Flux@0.13.17/ref/Flux.loadmodel!"},{"tag":"sourcefile","title":"Flux/train.jl","docid":"Flux@0.13.17/src/train.jl"},{"tag":"sourcefile","title":"Flux/layers/recurrent.jl","docid":"Flux@0.13.17/src/layers/recurrent.jl"},{"tag":"sourcefile","title":"Flux/optimise/optimisers.jl","docid":"Flux@0.13.17/src/optimise/optimisers.jl"},{"tag":"documentation","title":"CancelStepException","docid":"FluxTraining@0.3.8/ref/FluxTraining.CancelStepException"},{"tag":"document","title":"Variational autoencoders","docid":"FastAI@dev/doc/docs/notebooks/vae.ipynb"},{"tag":"documentation","title":"RNN","docid":"Flux@0.13.17/ref/Flux.RNN"},{"tag":"sourcefile","title":"Flux/loading.jl","docid":"Flux@0.13.17/src/loading.jl"}],"methods":[{"symbol_id":"Flux.state","module_id":"Flux","file":"loading.jl","line":173,"signature":"(::Signature)"}],"package_id":"Flux@0.13.17","title":"state","symbol_id":"Flux.state","exported":false,"module_id":"Flux"},"tag":"documentation","children":[{"attributes":{"symbol":"Flux.state","line":112,"module":"Flux","file":"loading.jl"},"tag":"docstring","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["state(x)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Return an object with the same nested structure as ",{"attributes":{},"tag":"code","children":["x"],"type":"node"}," according to ",{"attributes":{},"tag":"code","children":["Functors.children"],"type":"node"},", but made only of basic containers (e.g. named tuples, tuples, arrays, and dictionaries)."],"type":"node"},{"attributes":{},"tag":"p","children":["Besides trainable and non-trainable arrays, the state will contain leaf nodes that are not arrays, such as numbers, symbols, strings, and nothing values. The leaf types that end up in the state could increase in the future."],"type":"node"},{"attributes":{},"tag":"p","children":["This method is particularly useful for saving and loading models, since the state contain only simple data types that can be easily serialized."],"type":"node"},{"attributes":{},"tag":"p","children":["The state can be passed to ",{"attributes":{"reftype":"symbol","href":"@ref","title":"","document_id":"Flux@0.13.17/ref/Flux.loadmodel!"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["loadmodel!"],"type":"node"}],"type":"node"}," to restore the model."],"type":"node"},{"attributes":{},"tag":"h1","children":["Examples"],"type":"node"},{"attributes":{},"tag":"h2","children":["Copy the state into another model"],"type":"node"},{"attributes":{"lang":"jldoctest"},"tag":"codeblock","children":["julia> m1 = Chain(Dense(1, 2, tanh; init=ones), Dense(2, 1; init=ones));\n\njulia> s = Flux.state(m1)\n(layers = ((weight = [1.0; 1.0;;], bias = [0.0, 0.0], σ = ()), (weight = [1.0 1.0], bias = [0.0], σ = ())),)\n\njulia> m2 = Chain(Dense(1, 2, tanh), Dense(2, 1; bias=false));  # weights are random numbers\n\njulia> Flux.loadmodel!(m2, s);\n\njulia> m2[1].weight   # now the weights of m2 are the same as m1\n2×1 Matrix{Float32}:\n 1.0\n 1.0\n\njulia> Flux.state(trainmode!(Dropout(0.2)))  # contains p & activity, but not RNG state\n(p = 0.2, dims = (), active = true, rng = ())\n\njulia> Flux.state(BatchNorm(1))  # contains non-trainable arrays μ, σ²\n(λ = (), β = Float32[0.0], γ = Float32[1.0], μ = Float32[0.0], σ² = Float32[1.0], ϵ = 1.0f-5, momentum = 0.1f0, affine = true, track_stats = true, active = nothing, chs = 1)\n"],"type":"node"},{"attributes":{},"tag":"h2","children":["Save and load with BSON"],"type":"node"},{"attributes":{"lang":"julia-repl"},"tag":"codeblock","children":["julia> using BSON\n\njulia> BSON.@save \"checkpoint.bson\" model_state = s\n\njulia> Flux.loadmodel!(m2, BSON.load(\"checkpoint.bson\")[:model_state])\n"],"type":"node"},{"attributes":{},"tag":"h2","children":["Save and load with JLD2"],"type":"node"},{"attributes":{"lang":"julia-repl"},"tag":"codeblock","children":["julia> using JLD2\n\njulia> JLD2.jldsave(\"checkpoint.jld2\", model_state = s)\n\njulia> Flux.loadmodel!(m2, JLD2.load(\"checkpoint.jld2\", \"model_state\"))\n"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}