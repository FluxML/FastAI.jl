{"attributes":{"kind":"function","backlinks":[{"tag":"sourcefile","title":"Flux/utils.jl","docid":"Flux@0.13.11/src/utils.jl"}],"methods":[{"symbol_id":"Flux.truncated_normal","module_id":"Flux","file":"utils.jl","line":268,"signature":"(::Signature)"},{"symbol_id":"Flux.truncated_normal","module_id":"Flux","file":"utils.jl","line":251,"signature":"(::Signature)"},{"symbol_id":"Flux.truncated_normal","module_id":"Flux","file":"utils.jl","line":267,"signature":"(::Signature)"}],"package_id":"Flux@0.13.11","title":"truncated_normal","symbol_id":"Flux.truncated_normal","exported":false,"module_id":"Flux"},"tag":"documentation","children":[{"attributes":{"symbol":"Flux.truncated_normal","line":226,"module":"Flux","file":"utils.jl"},"tag":"docstring","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["truncated_normal([rng = default_rng_value()], size...; mean = 0, std = 1, lo = -2, hi = 2) -> Array\ntruncated_normal([rng]; kw...) -> Function\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Return an ",{"attributes":{},"tag":"code","children":["Array{Float32}"],"type":"node"}," of the given ",{"attributes":{},"tag":"code","children":["size"],"type":"node"}," where each element is drawn from a truncated normal distribution. The numbers are distributed like ",{"attributes":{},"tag":"code","children":["filter(x -> lo<=x<=hi, mean .+ std .* randn(100))"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["The values are generated by sampling a Uniform(0, 1) (",{"attributes":{},"tag":"code","children":["rand()"],"type":"node"},") and then applying the inverse CDF of the truncated normal distribution. This method works best when ",{"attributes":{},"tag":"code","children":["lo ≤ mean ≤ hi"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"h1","children":["Examples"],"type":"node"},{"attributes":{"lang":"jldoctest"},"tag":"codeblock","children":["julia> using Statistics\n\njulia> Flux.truncated_normal(3, 4) |> summary\n\"3×4 Matrix{Float32}\"\n\njulia> round.(extrema(Flux.truncated_normal(10^6)); digits=3)\n(-2.0f0, 2.0f0)\n\njulia> round(std(Flux.truncated_normal(10^6; lo = -100, hi = 100)))\n1.0f0\n"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}