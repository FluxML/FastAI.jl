{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"MLUtils/src/MLUtils.jl","docid":"sourcefiles/MLUtils/src/MLUtils.jl"},{"tag":"sourcefile","title":"FastAI/src/tasks/taskdata.jl","docid":"sourcefiles/FastAI/src/tasks/taskdata.jl"},{"tag":"sourcefile","title":"Flux/src/data/Data.jl","docid":"sourcefiles/Flux/src/data/Data.jl"},{"tag":"sourcefile","title":"MLUtils/src/eachobs.jl","docid":"sourcefiles/MLUtils/src/eachobs.jl"},{"tag":"sourcefile","title":"Flux/src/Flux.jl","docid":"sourcefiles/Flux/src/Flux.jl"},{"tag":"document","title":"Siamese image similarity","docid":"documents/docs/notebooks/siamese.ipynb"},{"tag":"document","title":"fastai API comparison","docid":"documents/docs/fastai_api_comparison.md"},{"tag":"documentation","title":"taskdataloaders","docid":"references/FastAI.taskdataloaders"},{"tag":"sourcefile","title":"FastAI/src/FastAI.jl","docid":"sourcefiles/FastAI/src/FastAI.jl"}],"methods":[{"line":138,"file":"/home/runner/.julia/packages/MLUtils/1VpUo/src/eachobs.jl","method_id":"MLUtils.DataLoader_1","symbol_id":"MLUtils.DataLoader","filedoc":"sourcefiles/MLUtils/src/eachobs.jl","signature":"MLUtils.DataLoader(data; buffer, parallel, shuffle, batchsize, partial, collate, rng)"},{"line":128,"file":"/home/runner/.julia/packages/MLUtils/1VpUo/src/eachobs.jl","method_id":"MLUtils.DataLoader_2","symbol_id":"MLUtils.DataLoader","filedoc":"sourcefiles/MLUtils/src/eachobs.jl","signature":"MLUtils.DataLoader(data::T, batchsize::Int64, buffer::Bool, partial::Bool, shuffle::Bool, parallel::Bool, collate::C, rng::R)"}],"name":"DataLoader","title":"DataLoader","symbol_id":"MLUtils.DataLoader","public":true,"module_id":"MLUtils"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["DataLoader(data; [batchsize, buffer, collate, parallel, partial, rng, shuffle])\n"],"type":"node"},{"attributes":{},"tag":"p","children":["An object that iterates over mini-batches of ",{"attributes":{},"tag":"code","children":["data"],"type":"node"},", each mini-batch containing ",{"attributes":{},"tag":"code","children":["batchsize"],"type":"node"}," observations (except possibly the last one)."],"type":"node"},{"attributes":{},"tag":"p","children":["Takes as input a single data array, a tuple (or a named tuple) of arrays, or in general any ",{"attributes":{},"tag":"code","children":["data"],"type":"node"}," object that implements the ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"references/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["numobs"],"type":"node"}],"type":"node"}," and ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"references/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["getobs"],"type":"node"}],"type":"node"}," methods."],"type":"node"},{"attributes":{},"tag":"p","children":["The last dimension in each array is the observation dimension, i.e. the one divided into mini-batches."],"type":"node"},{"attributes":{},"tag":"p","children":["The original data is preserved in the ",{"attributes":{},"tag":"code","children":["data"],"type":"node"}," field of the DataLoader."],"type":"node"},{"attributes":{},"tag":"h1","children":["Arguments"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["data"],"type":"node"},": The data to be iterated over. The data type has to be supported by ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"references/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["numobs"],"type":"node"}],"type":"node"}," and ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"references/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["getobs"],"type":"node"}],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["batchsize"],"type":"node"},": If less than 0, iterates over individual observations. Otherwise, each iteration (except possibly the last) yields a mini-batch containing ",{"attributes":{},"tag":"code","children":["batchsize"],"type":"node"}," observations. Default ",{"attributes":{},"tag":"code","children":["1"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["buffer"],"type":"node"},": If ",{"attributes":{},"tag":"code","children":["buffer=true"],"type":"node"}," and supported by the type of ",{"attributes":{},"tag":"code","children":["data"],"type":"node"},", a buffer will be allocated and reused for memory efficiency. You can also pass a preallocated object to ",{"attributes":{},"tag":"code","children":["buffer"],"type":"node"},". Default ",{"attributes":{},"tag":"code","children":["false"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["collate"],"type":"node"},": Batching behavior. If ",{"attributes":{},"tag":"code","children":["nothing"],"type":"node"}," (default), a batch is ",{"attributes":{},"tag":"code","children":["getobs(data, indices)"],"type":"node"},". If ",{"attributes":{},"tag":"code","children":["false"],"type":"node"},", each batch is ",{"attributes":{},"tag":"code","children":["[getobs(data, i) for i in indices]"],"type":"node"},". When ",{"attributes":{},"tag":"code","children":["true"],"type":"node"},", applies ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"references/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["batch"],"type":"node"}],"type":"node"}," to the vector of observations in a batch, recursively collating arrays in the last dimensions. See ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"references/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["batch"],"type":"node"}],"type":"node"}," for more information and examples."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["parallel"],"type":"node"},": Whether to use load data in parallel using worker threads. Greatly speeds up data loading by factor of available threads. Requires starting Julia with multiple threads. Check ",{"attributes":{},"tag":"code","children":["Threads.nthreads()"],"type":"node"}," to see the number of available threads. ",{"attributes":{},"tag":"strong","children":["Passing ",{"attributes":{},"tag":"code","children":["parallel = true"],"type":"node"}," breaks ordering guarantees"],"type":"node"},". Default ",{"attributes":{},"tag":"code","children":["false"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["partial"],"type":"node"},": This argument is used only when ",{"attributes":{},"tag":"code","children":["batchsize > 0"],"type":"node"},". If ",{"attributes":{},"tag":"code","children":["partial=false"],"type":"node"}," and the number of observations is not divisible by the batchsize, then the last mini-batch is dropped. Default ",{"attributes":{},"tag":"code","children":["true"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["rng"],"type":"node"},": A random number generator. Default ",{"attributes":{},"tag":"code","children":["Random.GLOBAL_RNG"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["shuffle"],"type":"node"},": Whether to shuffle the observations before iterating. Unlike wrapping the data container with ",{"attributes":{},"tag":"code","children":["shuffleobs(data)"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["shuffle=true"],"type":"node"}," ensures that the observations are shuffled anew every time you start iterating over ",{"attributes":{},"tag":"code","children":["eachobs"],"type":"node"},". Default ",{"attributes":{},"tag":"code","children":["false"],"type":"node"},"."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h1","children":["Examples"],"type":"node"},{"attributes":{"lang":"jldoctest"},"tag":"codeblock","children":["julia> Xtrain = rand(10, 100);\n\njulia> array_loader = DataLoader(Xtrain, batchsize=2);\n\njulia> for x in array_loader\n         @assert size(x) == (10, 2)\n         # do something with x, 50 times\n       end\n\njulia> array_loader.data === Xtrain\ntrue\n\njulia> tuple_loader = DataLoader((Xtrain,), batchsize=2);  # similar, but yielding 1-element tuples\n\njulia> for x in tuple_loader\n         @assert x isa Tuple{Matrix}\n         @assert size(x[1]) == (10, 2)\n       end\n\njulia> Ytrain = rand('a':'z', 100);  # now make a DataLoader yielding 2-element named tuples\n\njulia> train_loader = DataLoader((data=Xtrain, label=Ytrain), batchsize=5, shuffle=true);\n\njulia> for epoch in 1:100\n         for (x, y) in train_loader  # access via tuple destructuring\n           @assert size(x) == (10, 5)\n           @assert size(y) == (5,)\n           # loss += f(x, y) # etc, runs 100 * 20 times\n         end\n       end\n\njulia> first(train_loader).label isa Vector{Char}  # access via property name\ntrue\n\njulia> first(train_loader).label == Ytrain[1:5]  # because of shuffle=true\nfalse\n\njulia> foreach(println∘summary, DataLoader(rand(Int8, 10, 64), batchsize=30))  # partial=false would omit last\n10×30 Matrix{Int8}\n10×30 Matrix{Int8}\n10×4 Matrix{Int8}\n"],"type":"node"}],"type":"node"}],"type":"node"}