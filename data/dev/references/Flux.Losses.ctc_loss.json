{"attributes":{"kind":"function","backlinks":[{"tag":"sourcefile","title":"Flux/src/losses/Losses.jl","docid":"sourcefiles/Flux/src/losses/Losses.jl"},{"tag":"sourcefile","title":"Flux/src/losses/ctc.jl","docid":"sourcefiles/Flux/src/losses/ctc.jl"}],"methods":[{"line":356,"file":"/home/runner/.julia/packages/Flux/KkC79/src/losses/ctc.jl","method_id":"Flux.Losses.ctc_loss_1","symbol_id":"Flux.Losses.ctc_loss","filedoc":"sourcefiles/Flux/src/losses/ctc.jl","signature":"ctc_loss(ŷ::CUDA.CuArray, y)"},{"line":134,"file":"/home/runner/.julia/packages/Flux/KkC79/src/losses/ctc.jl","method_id":"Flux.Losses.ctc_loss_2","symbol_id":"Flux.Losses.ctc_loss","filedoc":"sourcefiles/Flux/src/losses/ctc.jl","signature":"ctc_loss(ŷ::AbstractArray, y)"}],"name":"ctc_loss","title":"ctc_loss","symbol_id":"Flux.Losses.ctc_loss","public":true,"module_id":"Flux.Losses"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"p","children":["ctc_loss(ŷ, y)"],"type":"node"},{"attributes":{},"tag":"p","children":["Computes the connectionist temporal classification loss between ",{"attributes":{},"tag":"code","children":["ŷ"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["y"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["ŷ"],"type":"node"}," must be a classes-by-time matrices, i.e., each row represents a class and each column represents a time step. Additionally, the ",{"attributes":{},"tag":"code","children":["logsoftmax"],"type":"node"}," function will be applied to ",{"attributes":{},"tag":"code","children":["ŷ"],"type":"node"},", so ",{"attributes":{},"tag":"code","children":["ŷ"],"type":"node"}," must be the raw activation values from the neural network and not, for example, the activations after being passed through a ",{"attributes":{},"tag":"code","children":["softmax"],"type":"node"}," activation function. ",{"attributes":{},"tag":"code","children":["y"],"type":"node"}," must be a 1D array of the labels associated with ",{"attributes":{},"tag":"code","children":["ŷ"],"type":"node"},". The blank label is assumed to be the last label category in ",{"attributes":{},"tag":"code","children":["ŷ"],"type":"node"},", so it is equivalent to ",{"attributes":{},"tag":"code","children":["size(ŷ, 1)"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["Used for sequence-to-sequence classification problems such as speech recognition and handwriting recognition where the exact time-alignment of the output (e.g., letters) is not needed to solve the problem. See ",{"attributes":{"href":"https://www.cs.toronto.edu/%7Egraves/icml_2006.pdf","title":""},"tag":"a","children":["Graves et al. (2006)"],"type":"node"}," or ",{"attributes":{"href":"https://www.cs.toronto.edu/%7Egraves/preprint.pdf#chapter.7","title":""},"tag":"a","children":["Graves (2012)"],"type":"node"}," for mathematical details."],"type":"node"}],"type":"node"}],"type":"node"}