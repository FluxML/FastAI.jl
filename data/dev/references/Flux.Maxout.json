{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"Flux/src/layers/basic.jl","docid":"sourcefiles/Flux/src/layers/basic.jl"},{"tag":"sourcefile","title":"Flux/src/Flux.jl","docid":"sourcefiles/Flux/src/Flux.jl"},{"tag":"sourcefile","title":"Flux/src/layers/show.jl","docid":"sourcefiles/Flux/src/layers/show.jl"}],"methods":[{"line":292,"file":"/home/runner/.julia/packages/Flux/KkC79/src/layers/basic.jl","method_id":"Flux.Maxout_1","symbol_id":"Flux.Maxout","filedoc":"sourcefiles/Flux/src/layers/basic.jl","signature":"Maxout(f::Function, n_alts::Integer)"},{"line":289,"file":"/home/runner/.julia/packages/Flux/KkC79/src/layers/basic.jl","method_id":"Flux.Maxout_2","symbol_id":"Flux.Maxout","filedoc":"sourcefiles/Flux/src/layers/basic.jl","signature":"Maxout(layers::T)"},{"line":291,"file":"/home/runner/.julia/packages/Flux/KkC79/src/layers/basic.jl","method_id":"Flux.Maxout_3","symbol_id":"Flux.Maxout","filedoc":"sourcefiles/Flux/src/layers/basic.jl","signature":"Maxout(layers...)"}],"name":"Maxout","title":"Maxout","symbol_id":"Flux.Maxout","public":true,"module_id":"Flux"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["Maxout(layers...)\nMaxout(f, n_alts)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["This contains a number of internal layers, each of which receives the same input. Its output is the elementwise maximum of the the internal layers' outputs."],"type":"node"},{"attributes":{},"tag":"p","children":["Instead of defining layers individually, you can provide a zero-argument function which constructs them, and the number to construct."],"type":"node"},{"attributes":{},"tag":"p","children":["Maxout over linear dense layers satisfies the univeral approximation theorem. See Goodfellow, Warde-Farley, Mirza, Courville & Bengio \"Maxout Networks\" ",{"attributes":{"reftype":"document","href":"1302.4389","title":"","document_id":"references/1302.4389"},"tag":"reference","children":["https://arxiv.org/abs/1302.4389"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["See also ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"references/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["Parallel"],"type":"node"}],"type":"node"}," to reduce with other operators."],"type":"node"},{"attributes":{},"tag":"h1","children":["Examples"],"type":"node"},{"attributes":{"lang":"jldoctest"},"tag":"codeblock","children":["julia> m = Maxout(x -> abs2.(x), x -> x .* 3);\n\njulia> m([-2 -1 0 1 2])\n1Ã—5 Matrix{Int64}:\n 4  1  0  3  6\n\njulia> m3 = Maxout(() -> Dense(5 => 7, tanh), 3)\nMaxout(\n  Dense(5 => 7, tanh),                  # 42 parameters\n  Dense(5 => 7, tanh),                  # 42 parameters\n  Dense(5 => 7, tanh),                  # 42 parameters\n)                   # Total: 6 arrays, 126 parameters, 888 bytes.\n\njulia> Flux.outputsize(m3, (5, 11))\n(7, 11)\n"],"type":"node"}],"type":"node"}],"type":"node"}