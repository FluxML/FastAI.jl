{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"Flux/src/layers/normalise.jl","docid":"sourcefiles/Flux/src/layers/normalise.jl"},{"tag":"sourcefile","title":"Flux/src/Flux.jl","docid":"sourcefiles/Flux/src/Flux.jl"},{"tag":"sourcefile","title":"Flux/src/layers/show.jl","docid":"sourcefiles/Flux/src/layers/show.jl"},{"tag":"sourcefile","title":"Flux/src/outputsize.jl","docid":"sourcefiles/Flux/src/outputsize.jl"}],"methods":[{"line":527,"file":"/home/runner/.julia/packages/Flux/KkC79/src/layers/normalise.jl","method_id":"Flux.GroupNorm_1","symbol_id":"Flux.GroupNorm","filedoc":"sourcefiles/Flux/src/layers/normalise.jl","signature":"GroupNorm(chs::Int64, G::Int64)"},{"line":510,"file":"/home/runner/.julia/packages/Flux/KkC79/src/layers/normalise.jl","method_id":"Flux.GroupNorm_2","symbol_id":"Flux.GroupNorm","filedoc":"sourcefiles/Flux/src/layers/normalise.jl","signature":"GroupNorm(G::Int64, λ::F, β::V, γ::V, μ::W, σ²::W, ϵ::N, momentum::N, affine::Bool, track_stats::Bool, active::Union{Nothing, Bool}, chs::Int64)"},{"line":527,"file":"/home/runner/.julia/packages/Flux/KkC79/src/layers/normalise.jl","method_id":"Flux.GroupNorm_3","symbol_id":"Flux.GroupNorm","filedoc":"sourcefiles/Flux/src/layers/normalise.jl","signature":"GroupNorm(chs::Int64, G::Int64, λ; initβ, initγ, affine, track_stats, ϵ, momentum)"}],"name":"GroupNorm","title":"GroupNorm","symbol_id":"Flux.GroupNorm","public":true,"module_id":"Flux"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["GroupNorm(channels::Integer, G::Integer, λ=identity;\n          initβ=zeros32, initγ=ones32,\n          affine=true, track_stats=false,\n          ϵ=1f-5, momentum=0.1f0)\n"],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{"href":"https://arxiv.org/abs/1803.08494","title":""},"tag":"a","children":["Group Normalization"],"type":"node"}," layer."],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["chs"],"type":"node"}," is the number of channels, the channel dimension of your input. For an array of N dimensions, the ",{"attributes":{},"tag":"code","children":["N-1"],"type":"node"},"th index is the channel dimension."],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["G"],"type":"node"}," is the number of groups along which the statistics are computed. The number of channels must be an integer multiple of the number of groups."],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["channels"],"type":"node"}," should be the size of the channel dimension in your data (see below)."],"type":"node"},{"attributes":{},"tag":"p","children":["Given an array with ",{"attributes":{},"tag":"code","children":["N > 2"],"type":"node"}," dimensions, call the ",{"attributes":{},"tag":"code","children":["N-1"],"type":"node"},"th the channel dimension. For ",{"attributes":{},"tag":"code","children":["WHCN"],"type":"node"}," images it's the usual channel dimension."],"type":"node"},{"attributes":{},"tag":"p","children":["If ",{"attributes":{},"tag":"code","children":["affine=true"],"type":"node"},", it also applies  a shift and a rescale to the input through to learnable per-channel bias ",{"attributes":{},"tag":"code","children":["β"],"type":"node"}," and scale ",{"attributes":{},"tag":"code","children":["γ"],"type":"node"}," parameters."],"type":"node"},{"attributes":{},"tag":"p","children":["If ",{"attributes":{},"tag":"code","children":["track_stats=true"],"type":"node"},", accumulates mean and var statistics in training phase that will be used to renormalize the input in test phase."],"type":"node"},{"attributes":{},"tag":"h1","children":["Examples"],"type":"node"},{"attributes":{"lang":"jldoctest"},"tag":"codeblock","children":["julia> using Statistics\n\njulia> xs = rand(3, 3, 4, 2);  # a batch of 2 images, each having 4 channels\n\njulia> m = GroupNorm(4, 2);\n\njulia> y = m(xs);\n\njulia> isapprox(std(y[:, :, 1:2, 1]), 1, atol=0.1) && std(xs[:, :, 1:2, 1]) != std(y[:, :, 1:2, 1])\ntrue\n\njulia> isapprox(std(y[:, :, 3:4, 2]), 1, atol=0.1) && std(xs[:, :, 3:4, 2]) != std(y[:, :, 3:4, 2])\ntrue\n"],"type":"node"}],"type":"node"}],"type":"node"}