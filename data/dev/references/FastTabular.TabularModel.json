{"attributes":{"kind":"function","backlinks":[{"tag":"sourcefile","title":"FastTabular/src/models.jl","docid":"sourcefiles/FastTabular/src/models.jl"},{"tag":"sourcefile","title":"FastTabular/src/encodings/tabularpreprocessing.jl","docid":"sourcefiles/FastTabular/src/encodings/tabularpreprocessing.jl"}],"methods":[{"line":91,"file":"/home/runner/work/FastAI.jl/FastAI.jl/FastTabular/src/models.jl","method_id":"FastTabular.TabularModel_1","symbol_id":"FastTabular.TabularModel","filedoc":"sourcefiles/FastTabular/src/models.jl","signature":"TabularModel(n_cont::Number, outsize::Number)"},{"line":91,"file":"/home/runner/work/FastAI.jl/FastAI.jl/FastTabular/src/models.jl","method_id":"FastTabular.TabularModel_2","symbol_id":"FastTabular.TabularModel","filedoc":"sourcefiles/FastTabular/src/models.jl","signature":"TabularModel(n_cont::Number, outsize::Number, layersizes; cardinalities, size_overrides)"},{"line":27,"file":"/home/runner/work/FastAI.jl/FastAI.jl/FastTabular/src/models.jl","method_id":"FastTabular.TabularModel_3","symbol_id":"FastTabular.TabularModel","filedoc":"sourcefiles/FastTabular/src/models.jl","signature":"TabularModel(catbackbone, contbackbone; outsize, layersizes, kwargs...)"},{"line":36,"file":"/home/runner/work/FastAI.jl/FastAI.jl/FastTabular/src/models.jl","method_id":"FastTabular.TabularModel_4","symbol_id":"FastTabular.TabularModel","filedoc":"sourcefiles/FastTabular/src/models.jl","signature":"TabularModel(catbackbone, contbackbone, finalclassifier; layersizes, dropout_rates, batchnorm, activation, linear_first)"}],"name":"TabularModel","title":"TabularModel","symbol_id":"FastTabular.TabularModel","public":false,"module_id":"FastTabular"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["TabularModel(catbackbone, contbackbone, [finalclassifier]; kwargs...)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Create a tabular model which operates on a tuple of categorical values (label or one-hot encoded) and continuous values. The categorical backbones (",{"attributes":{},"tag":"code","children":["catbackbone"],"type":"node"},") and continuous backbone (",{"attributes":{},"tag":"code","children":["contbackbone"],"type":"node"},") operate on each element of the input tuple. The output from these backbones is then passed through a series of linear-batch norm-dropout layers before a ",{"attributes":{},"tag":"code","children":["finalclassifier"],"type":"node"}," block."],"type":"node"},{"attributes":{},"tag":"h2","children":["Keyword arguments"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["outsize"],"type":"node"},": The output size of the final classifier block. For single classification tasks, this would be the number of classes, and for regression tasks, this would be the number of target continuous variables."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["layersizes"],"type":"node"},": A vector of sizes for each hidden layer in the sequence of linear layers."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["dropout_rates"],"type":"node"},": Dropout probabilities for the linear-batch norm-dropout layers. This could either be a single number which would be used for for all the layers, or a collection of numbers which are cycled through for each layer."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["batchnorm"],"type":"node"},": Set to ",{"attributes":{},"tag":"code","children":["false"],"type":"node"}," to skip each batch norm in the linear-batch norm-dropout sequence."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["activation"],"type":"node"},": The activation function to use in the classifier layers."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["linear_first"],"type":"node"},": Controls if the linear layer comes before or after batch norm and dropout."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"hr","children":[],"type":"node"},{"attributes":{"lang":""},"tag":"codeblock","children":["TabularModel(n_cont, outsize, [layersizes; kwargs...])\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Create a tabular model which operates on a tuple of categorical values (label or one-hot encoded) and continuous values. The default categorical backbone (",{"attributes":{},"tag":"code","children":["catbackbone"],"type":"node"},") is a ",{"attributes":{"href":"https://fluxml.ai/Flux.jl/stable/models/layers/#Flux.Parallel","title":""},"tag":"a","children":[{"attributes":{},"tag":"code","children":["Flux.Parallel"],"type":"node"}],"type":"node"}," set of ",{"attributes":{},"tag":"code","children":["Flux.Embedding"],"type":"node"}," layers corresponding to each categorical variable. The default continuous backbone (",{"attributes":{},"tag":"code","children":["contbackbone"],"type":"node"},") is a single ",{"attributes":{"href":"https://fluxml.ai/Flux.jl/stable/models/layers/#Flux.BatchNorm","title":""},"tag":"a","children":[{"attributes":{},"tag":"code","children":["Flux.BatchNorm"],"type":"node"}],"type":"node"},". The output from these backbones is concatenated then passed through a series of linear-batch norm-dropout layers before a ",{"attributes":{},"tag":"code","children":["finalclassifier"],"type":"node"}," block."],"type":"node"},{"attributes":{},"tag":"h2","children":["Arguments"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["n_cont"],"type":"node"},": The number of continuous columns."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["outsize"],"type":"node"},": The output size of the model."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["layersizes"],"type":"node"},": A vector of sizes for each hidden layer in the sequence of linear layers."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Keyword arguments"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["cardinalities"],"type":"node"},": A collection of sizes (number of classes) for each categorical column."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["size_overrides"],"type":"node"},": An optional argument which corresponds to a collection containing embedding sizes to override the value returned by the \"rule of thumb\" for a particular index corresponding to ",{"attributes":{},"tag":"code","children":["cardinalities"],"type":"node"},", or ",{"attributes":{},"tag":"code","children":["nothing"],"type":"node"},"."],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}