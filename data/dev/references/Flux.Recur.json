{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"Flux/src/deprecations.jl","docid":"sourcefiles/Flux/src/deprecations.jl"},{"tag":"documentation","title":"RNN","docid":"references/Flux.RNN"},{"tag":"sourcefile","title":"Flux/src/layers/show.jl","docid":"sourcefiles/Flux/src/layers/show.jl"},{"tag":"sourcefile","title":"Flux/src/layers/recurrent.jl","docid":"sourcefiles/Flux/src/layers/recurrent.jl"}],"methods":[{"line":478,"file":"/home/runner/.julia/packages/Flux/KkC79/src/layers/recurrent.jl","method_id":"Flux.Recur_1","symbol_id":"Flux.Recur","filedoc":"sourcefiles/Flux/src/layers/recurrent.jl","signature":"Flux.Recur(m::Flux.GRUv3Cell)"},{"line":413,"file":"/home/runner/.julia/packages/Flux/KkC79/src/layers/recurrent.jl","method_id":"Flux.Recur_2","symbol_id":"Flux.Recur","filedoc":"sourcefiles/Flux/src/layers/recurrent.jl","signature":"Flux.Recur(m::Flux.GRUCell)"},{"line":344,"file":"/home/runner/.julia/packages/Flux/KkC79/src/layers/recurrent.jl","method_id":"Flux.Recur_3","symbol_id":"Flux.Recur","filedoc":"sourcefiles/Flux/src/layers/recurrent.jl","signature":"Flux.Recur(m::Flux.LSTMCell)"},{"line":276,"file":"/home/runner/.julia/packages/Flux/KkC79/src/layers/recurrent.jl","method_id":"Flux.Recur_4","symbol_id":"Flux.Recur","filedoc":"sourcefiles/Flux/src/layers/recurrent.jl","signature":"Flux.Recur(m::Flux.RNNCell)"},{"line":129,"file":"/home/runner/.julia/packages/Flux/KkC79/src/layers/recurrent.jl","method_id":"Flux.Recur_5","symbol_id":"Flux.Recur","filedoc":"sourcefiles/Flux/src/layers/recurrent.jl","signature":"Flux.Recur(cell::T, state::S)"}],"name":"Recur","title":"Recur","symbol_id":"Flux.Recur","public":false,"module_id":"Flux"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["Recur(cell)\n"],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["Recur"],"type":"node"}," takes a recurrent cell and makes it stateful, managing the hidden state in the background. ",{"attributes":{},"tag":"code","children":["cell"],"type":"node"}," should be a model of the form:"],"type":"node"},{"attributes":{"lang":""},"tag":"codeblock","children":["h, y = cell(h, x...)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["For example, here's a recurrent network that keeps a running total of its inputs:"],"type":"node"},{"attributes":{},"tag":"h1","children":["Examples"],"type":"node"},{"attributes":{"lang":"jldoctest"},"tag":"codeblock","children":["julia> accum(h, x) = (h + x, x)\naccum (generic function with 1 method)\n\njulia> rnn = Flux.Recur(accum, 0)\nRecur(accum)\n\njulia> rnn(2) \n2\n\njulia> rnn(3)\n3\n\njulia> rnn.state\n5\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Folding over a 3d Array of dimensions ",{"attributes":{},"tag":"code","children":["(features, batch, time)"],"type":"node"}," is also supported:"],"type":"node"},{"attributes":{"lang":"jldoctest"},"tag":"codeblock","children":["julia> accum(h, x) = (h .+ x, x)\naccum (generic function with 1 method)\n\njulia> rnn = Flux.Recur(accum, zeros(Int, 1, 1))\nRecur(accum)\n\njulia> rnn([2])\n1-element Vector{Int64}:\n 2\n\njulia> rnn([3])\n1-element Vector{Int64}:\n 3\n\njulia> rnn.state\n1×1 Matrix{Int64}:\n 5\n\njulia> out = rnn(reshape(1:10, 1, 1, :));  # apply to a sequence of (features, batch, time)\n\njulia> out |> size\n(1, 1, 10)\n\njulia> vec(out)\n10-element Vector{Int64}:\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n\njulia> rnn.state\n1×1 Matrix{Int64}:\n 60\n"],"type":"node"}],"type":"node"}],"type":"node"}