{"attributes":{"kind":"struct","backlinks":[{"tag":"documentation","title":"ParamGroups","docid":"references/FastAI.ParamGroups"},{"tag":"sourcefile","title":"Flux/src/deprecations.jl","docid":"sourcefiles/Flux/src/deprecations.jl"},{"tag":"sourcefile","title":"Flux/src/layers/basic.jl","docid":"sourcefiles/Flux/src/layers/basic.jl"},{"tag":"sourcefile","title":"FastTabular/src/models.jl","docid":"sourcefiles/FastTabular/src/models.jl"},{"tag":"sourcefile","title":"Flux/src/Flux.jl","docid":"sourcefiles/Flux/src/Flux.jl"},{"tag":"sourcefile","title":"Flux/src/layers/show.jl","docid":"sourcefiles/Flux/src/layers/show.jl"},{"tag":"sourcefile","title":"FastVision/src/models/blocks.jl","docid":"sourcefiles/FastVision/src/models/blocks.jl"},{"tag":"sourcefile","title":"FastAI/src/training/paramgroups.jl","docid":"sourcefiles/FastAI/src/training/paramgroups.jl"},{"tag":"sourcefile","title":"FastTabular/src/encodings/tabularpreprocessing.jl","docid":"sourcefiles/FastTabular/src/encodings/tabularpreprocessing.jl"},{"tag":"document","title":"Custom learning tasks","docid":"documents/docs/learning_methods.md"},{"tag":"document","title":"Variational autoencoders","docid":"documents/docs/notebooks/vae.ipynb"},{"tag":"documentation","title":"loadmodel!","docid":"references/Flux.loadmodel!"},{"tag":"sourcefile","title":"FastAI/src/training/discriminativelrs.jl","docid":"sourcefiles/FastAI/src/training/discriminativelrs.jl"},{"tag":"documentation","title":"DiscriminativeLRs","docid":"references/FastAI.DiscriminativeLRs"},{"tag":"sourcefile","title":"FastTabular/src/FastTabular.jl","docid":"sourcefiles/FastTabular/src/FastTabular.jl"}],"methods":[{"line":63,"file":"/home/runner/.julia/packages/Flux/KkC79/src/deprecations.jl","method_id":"Flux.Dense_1","symbol_id":"Flux.Dense","filedoc":"sourcefiles/Flux/src/deprecations.jl","signature":"Dense(in::Integer, out::Integer)"},{"line":63,"file":"/home/runner/.julia/packages/Flux/KkC79/src/deprecations.jl","method_id":"Flux.Dense_2","symbol_id":"Flux.Dense","filedoc":"sourcefiles/Flux/src/deprecations.jl","signature":"Dense(in::Integer, out::Integer, σ; kw...)"},{"line":163,"file":"/home/runner/.julia/packages/Flux/KkC79/src/layers/basic.jl","method_id":"Flux.Dense_3","symbol_id":"Flux.Dense","filedoc":"sourcefiles/Flux/src/layers/basic.jl","signature":"Dense(::Pair{<:Integer, <:Integer})"},{"line":163,"file":"/home/runner/.julia/packages/Flux/KkC79/src/layers/basic.jl","method_id":"Flux.Dense_4","symbol_id":"Flux.Dense","filedoc":"sourcefiles/Flux/src/layers/basic.jl","signature":"Dense(::Pair{<:Integer, <:Integer}, σ; init, bias)"},{"line":157,"file":"/home/runner/.julia/packages/Flux/KkC79/src/layers/basic.jl","method_id":"Flux.Dense_5","symbol_id":"Flux.Dense","filedoc":"sourcefiles/Flux/src/layers/basic.jl","signature":"Dense(W::M where M<:(AbstractMatrix)"},{"line":157,"file":"/home/runner/.julia/packages/Flux/KkC79/src/layers/basic.jl","method_id":"Flux.Dense_6","symbol_id":"Flux.Dense","filedoc":"sourcefiles/Flux/src/layers/basic.jl","signature":"Dense(W::M, bias where M<:(AbstractMatrix)"},{"line":157,"file":"/home/runner/.julia/packages/Flux/KkC79/src/layers/basic.jl","method_id":"Flux.Dense_7","symbol_id":"Flux.Dense","filedoc":"sourcefiles/Flux/src/layers/basic.jl","signature":"Dense(W::M, bias, σ::F where {M<:(AbstractMatrix)"}],"name":"Dense","title":"Dense","symbol_id":"Flux.Dense","public":true,"module_id":"Flux"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["Dense(in => out, σ=identity; bias=true, init=glorot_uniform)\nDense(W::AbstractMatrix, [bias, σ])\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Create a traditional fully connected layer, whose forward pass is given by:"],"type":"node"},{"attributes":{"lang":""},"tag":"codeblock","children":["y = σ.(W * x .+ bias)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["The input ",{"attributes":{},"tag":"code","children":["x"],"type":"node"}," should be a vector of length ",{"attributes":{},"tag":"code","children":["in"],"type":"node"},", or batch of vectors represented as an ",{"attributes":{},"tag":"code","children":["in × N"],"type":"node"}," matrix, or any array with ",{"attributes":{},"tag":"code","children":["size(x,1) == in"],"type":"node"},". The out ",{"attributes":{},"tag":"code","children":["y"],"type":"node"}," will be a vector  of length ",{"attributes":{},"tag":"code","children":["out"],"type":"node"},", or a batch with ",{"attributes":{},"tag":"code","children":["size(y) == (out, size(x)[2:end]...)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Keyword ",{"attributes":{},"tag":"code","children":["bias=false"],"type":"node"}," will switch off trainable bias for the layer. The initialisation of the weight matrix is ",{"attributes":{},"tag":"code","children":["W = init(out, in)"],"type":"node"},", calling the function given to keyword ",{"attributes":{},"tag":"code","children":["init"],"type":"node"},", with default [",{"attributes":{},"tag":"code","children":["glorot_uniform"],"type":"node"},"](",{"attributes":{},"tag":"citation","children":[],"type":"node"}," Flux.glorot_uniform). The weight matrix and/or the bias vector (of length ",{"attributes":{},"tag":"code","children":["out"],"type":"node"},") may also be provided explicitly."],"type":"node"},{"attributes":{},"tag":"h1","children":["Examples"],"type":"node"},{"attributes":{"lang":"jldoctest"},"tag":"codeblock","children":["julia> d = Dense(5 => 2)\nDense(5 => 2)       # 12 parameters\n\njulia> d(rand(Float32, 5, 64)) |> size\n(2, 64)\n\njulia> d(rand(Float32, 5, 1, 1, 64)) |> size  # treated as three batch dimensions\n(2, 1, 1, 64)\n\njulia> d1 = Dense(ones(2, 5), false, tanh)  # using provided weight matrix\nDense(5 => 2, tanh; bias=false)  # 10 parameters\n\njulia> d1(ones(5))\n2-element Vector{Float64}:\n 0.9999092042625951\n 0.9999092042625951\n\njulia> Flux.params(d1)  # no trainable bias\nParams([[1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0]])\n"],"type":"node"}],"type":"node"}],"type":"node"}