{"attributes":{"kind":"function","backlinks":[{"tag":"sourcefile","title":"Flux/src/utils.jl","docid":"sourcefiles/Flux/src/utils.jl"}],"methods":[{"line":256,"file":"/home/runner/.julia/packages/Flux/KkC79/src/utils.jl","method_id":"Flux.truncated_normal_1","symbol_id":"Flux.truncated_normal","filedoc":"sourcefiles/Flux/src/utils.jl","signature":"truncated_normal()"},{"line":256,"file":"/home/runner/.julia/packages/Flux/KkC79/src/utils.jl","method_id":"Flux.truncated_normal_2","symbol_id":"Flux.truncated_normal","filedoc":"sourcefiles/Flux/src/utils.jl","signature":"truncated_normal(rng::Random.AbstractRNG; init_kwargs...)"},{"line":239,"file":"/home/runner/.julia/packages/Flux/KkC79/src/utils.jl","method_id":"Flux.truncated_normal_3","symbol_id":"Flux.truncated_normal","filedoc":"sourcefiles/Flux/src/utils.jl","signature":"truncated_normal(rng::Random.AbstractRNG, dims::Integer...; mean, std, lo, hi)"},{"line":255,"file":"/home/runner/.julia/packages/Flux/KkC79/src/utils.jl","method_id":"Flux.truncated_normal_4","symbol_id":"Flux.truncated_normal","filedoc":"sourcefiles/Flux/src/utils.jl","signature":"truncated_normal(dims::Integer...; kwargs...)"}],"name":"truncated_normal","title":"truncated_normal","symbol_id":"Flux.truncated_normal","public":false,"module_id":"Flux"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["truncated_normal([rng=GLOBAL_RNG], size...; mean = 0, std = 1, lo = -2, hi = 2) -> Array\ntruncated_normal([rng]; kw...) -> Function\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Return an ",{"attributes":{},"tag":"code","children":["Array{Float32}"],"type":"node"}," of the given ",{"attributes":{},"tag":"code","children":["size"],"type":"node"}," where each element is drawn from a truncated normal distribution. The numbers are distributed like ",{"attributes":{},"tag":"code","children":["filter(x -> lo<=x<=hi, mean .+ std .* randn(100))"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["The values are generated by sampling a Uniform(0, 1) (",{"attributes":{},"tag":"code","children":["rand()"],"type":"node"},") and then applying the inverse CDF of the truncated normal distribution. This method works best when ",{"attributes":{},"tag":"code","children":["lo ≤ mean ≤ hi"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"h1","children":["Examples"],"type":"node"},{"attributes":{"lang":"jldoctest"},"tag":"codeblock","children":["julia> using Statistics\n\njulia> Flux.truncated_normal(3, 4) |> summary\n\"3×4 Matrix{Float32}\"\n\njulia> round.(extrema(Flux.truncated_normal(10^6)); digits=3)\n(-2.0f0, 2.0f0)\n\njulia> round(std(Flux.truncated_normal(10^6; lo = -100, hi = 100)))\n1.0f0\n"],"type":"node"}],"type":"node"}],"type":"node"}