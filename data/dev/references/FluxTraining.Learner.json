{"attributes":{"kind":"struct","backlinks":[{"tag":"document","title":"Interfaces","docid":"documents/docs/interfaces.md"},{"tag":"documentation","title":"StopOnNaNLoss","docid":"references/FluxTraining.StopOnNaNLoss"},{"tag":"document","title":"Image segmentation","docid":"documents/docs/notebooks/imagesegmentation.ipynb"},{"tag":"document","title":"Introduction","docid":"documents/docs/introduction.md"},{"tag":"sourcefile","title":"FluxTraining/src/FluxTraining.jl","docid":"sourcefiles/FluxTraining/src/FluxTraining.jl"},{"tag":"sourcefile","title":"FastAI/src/interpretation/learner.jl","docid":"sourcefiles/FastAI/src/interpretation/learner.jl"},{"tag":"documentation","title":"MetricsPrinter","docid":"references/FluxTraining.MetricsPrinter"},{"tag":"documentation","title":"EarlyStopping","docid":"references/FluxTraining.EarlyStopping"},{"tag":"document","title":"Tabular Classification","docid":"documents/docs/notebooks/tabularclassification.ipynb"},{"tag":"documentation","title":"LogMetrics","docid":"references/FluxTraining.LogMetrics"},{"tag":"sourcefile","title":"FluxTraining/src/testutils.jl","docid":"sourcefiles/FluxTraining/src/testutils.jl"},{"tag":"sourcefile","title":"FluxTraining/src/learner.jl","docid":"sourcefiles/FluxTraining/src/learner.jl"},{"tag":"documentation","title":"Metrics","docid":"references/FluxTraining.Metrics"},{"tag":"document","title":"Siamese image similarity","docid":"documents/docs/notebooks/siamese.ipynb"},{"tag":"documentation","title":"Callback","docid":"references/FluxTraining.Callback"},{"tag":"document","title":"fastai API comparison","docid":"documents/docs/fastai_api_comparison.md"},{"tag":"documentation","title":"testlearner","docid":"references/FluxTraining.testlearner"},{"tag":"document","title":"Keypoint regression","docid":"documents/docs/notebooks/keypointregression.ipynb"},{"tag":"document","title":"Custom learning tasks","docid":"documents/docs/learning_methods.md"},{"tag":"sourcefile","title":"FastAI/src/FastAI.jl","docid":"sourcefiles/FastAI/src/FastAI.jl"},{"tag":"document","title":"Variational autoencoders","docid":"documents/docs/notebooks/vae.ipynb"},{"tag":"sourcefile","title":"FastAI/src/learner.jl","docid":"sourcefiles/FastAI/src/learner.jl"},{"tag":"documentation","title":"tasklearner","docid":"references/FastAI.tasklearner"},{"tag":"sourcefile","title":"FastAI/src/training/onecycle.jl","docid":"sourcefiles/FastAI/src/training/onecycle.jl"}],"methods":[{"line":15,"file":"/home/runner/.julia/packages/FluxTraining/iBFSd/src/learner.jl","method_id":"FluxTraining.Learner_1","symbol_id":"FluxTraining.Learner","filedoc":"sourcefiles/FluxTraining/src/learner.jl","signature":"Learner(model, data::FluxTraining.PropDict, optimizer, lossfn, params, step::FluxTraining.PropDict, callbacks::FluxTraining.Callbacks, cbstate::FluxTraining.PropDict)"},{"line":72,"file":"/home/runner/.julia/packages/FluxTraining/iBFSd/src/learner.jl","method_id":"FluxTraining.Learner_2","symbol_id":"FluxTraining.Learner","filedoc":"sourcefiles/FluxTraining/src/learner.jl","signature":"Learner(model, lossfn; callbacks, data, optimizer, kwargs...)"},{"line":80,"file":"/home/runner/.julia/packages/FluxTraining/iBFSd/src/learner.jl","method_id":"FluxTraining.Learner_3","symbol_id":"FluxTraining.Learner","filedoc":"sourcefiles/FluxTraining/src/learner.jl","signature":"Learner(model, data, optimizer, lossfn, callbacks::FluxTraining.SafeCallback...; usedefaultcallbacks, cbrunner)"},{"line":15,"file":"/home/runner/.julia/packages/FluxTraining/iBFSd/src/learner.jl","method_id":"FluxTraining.Learner_4","symbol_id":"FluxTraining.Learner","filedoc":"sourcefiles/FluxTraining/src/learner.jl","signature":"Learner(model, data, optimizer, lossfn, params, step, callbacks, cbstate)"}],"name":"Learner","title":"Learner","symbol_id":"FluxTraining.Learner","public":true,"module_id":"FluxTraining"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["Learner(model, lossfn; [callbacks = [], optimizer = ADAM(), kwargs...])\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Holds and coordinates all state of the training. ",{"attributes":{},"tag":"code","children":["model"],"type":"node"}," is trained by optimizing ",{"attributes":{},"tag":"code","children":["lossfn"],"type":"node"}," with ",{"attributes":{},"tag":"code","children":["optimizer"],"type":"node"}," on ",{"attributes":{},"tag":"code","children":["data"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"h2","children":["Arguments"],"type":"node"},{"attributes":{},"tag":"p","children":["Positional arguments:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["model"],"type":"node"},": A Flux.jl model or a ",{"attributes":{},"tag":"code","children":["NamedTuple"],"type":"node"}," of models."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["lossfn"],"type":"node"},": Loss function with signature ",{"attributes":{},"tag":"code","children":["lossfn(model(x), y) -> Number"],"type":"node"},"."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Keyword arguments (optional):"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["data = ()"],"type":"node"},": Data iterators. A 2-tuple will be treated as ",{"attributes":{},"tag":"code","children":["(trainingdataiter, validdataiter)"],"type":"node"},". You can also pass in an empty tuple ",{"attributes":{},"tag":"code","children":["()"],"type":"node"}," and use the ",{"attributes":{"reftype":"symbol","document_id":"references/FluxTraining.epoch!"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["epoch!"],"type":"node"}],"type":"node"}," method with a ",{"attributes":{},"tag":"code","children":["dataiter"],"type":"node"}," as third argument."],"type":"node"},{"attributes":{},"tag":"p","children":["A data iterator is an iterable over batches. For regular supervised training, each batch should be a tuple ",{"attributes":{},"tag":"code","children":["(xs, ys)"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["optimizer = ADAM()"],"type":"node"},": The optimizer used to update the ",{"attributes":{},"tag":"code","children":["model"],"type":"node"},"'s weights"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["callbacks = []"],"type":"node"},": A list of callbacks that should be used. If ",{"attributes":{},"tag":"code","children":["usedefaultcallbacks == true"],"type":"node"},", this will be extended by the default callbacks"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["usedefaultcallbacks = true"],"type":"node"},": Whether to add some basic callbacks. Included are ",{"attributes":{"reftype":"symbol","document_id":"references/FluxTraining.Metrics"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["Metrics"],"type":"node"}],"type":"node"},", ",{"attributes":{"reftype":"symbol","document_id":"references/FluxTraining.Recorder"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["Recorder"],"type":"node"}],"type":"node"},", ",{"attributes":{"reftype":"symbol","document_id":"references/FluxTraining.ProgressPrinter"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["ProgressPrinter"],"type":"node"}],"type":"node"},", ",{"attributes":{"reftype":"symbol","document_id":"references/FluxTraining.StopOnNaNLoss"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["StopOnNaNLoss"],"type":"node"}],"type":"node"},", and ",{"attributes":{"reftype":"symbol","document_id":"references/FluxTraining.MetricsPrinter"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["MetricsPrinter"],"type":"node"}],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["cbrunner = LinearRunner()"],"type":"node"},": Callback runner to use."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Fields"],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"em","children":["(Use this as a reference when implementing callbacks)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["model"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["optimizer"],"type":"node"},", and ",{"attributes":{},"tag":"code","children":["lossfn"],"type":"node"}," are stored as passed in"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["data"],"type":"node"}," is a ",{"attributes":{},"tag":"code","children":["PropDict"],"type":"node"}," of data iterators, usually ",{"attributes":{},"tag":"code","children":[":training"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":[":validation"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["params"],"type":"node"},": An instance of ",{"attributes":{},"tag":"code","children":["model"],"type":"node"},"'s parameters of type ",{"attributes":{},"tag":"code","children":["Flux.Params"],"type":"node"},". If ",{"attributes":{},"tag":"code","children":["model"],"type":"node"}," is a ",{"attributes":{},"tag":"code","children":["NamedTuple"],"type":"node"},", then ",{"attributes":{},"tag":"code","children":["params"],"type":"node"}," is a ",{"attributes":{},"tag":"code","children":["NamedTuple"],"type":"node"}," as well."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["step::"],"type":"node"},{"attributes":{"reftype":"symbol","document_id":"references/FluxTraining.PropDict"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["PropDict"],"type":"node"}],"type":"node"},": State of the last step. Contents depend on the last run ",{"attributes":{"reftype":"symbol","document_id":"references/FluxTraining.Phases.Phase"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["Phase"],"type":"node"}],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["cbstate::"],"type":"node"},{"attributes":{"reftype":"symbol","document_id":"references/FluxTraining.PropDict"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["PropDict"],"type":"node"}],"type":"node"},": Special state container that callbacks can save state to for other callbacks. Its keys depend on what callbacks are being used. See the ",{"attributes":{"reftype":"document","href":"/documents/docs/callbacks/custom.md","title":"","document_id":"documents/docs/callbacks/custom.md"},"tag":"reference","children":["custom callbacks guide"],"type":"node"}," for more info."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"hr","children":[],"type":"node"},{"attributes":{"lang":""},"tag":"codeblock","children":["Learner(model, data, optimizer, lossfn, [callbacks...; kwargs...])\n"],"type":"node"}],"type":"node"}],"type":"node"}