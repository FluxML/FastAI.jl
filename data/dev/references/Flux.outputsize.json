{"attributes":{"kind":"function","backlinks":[{"tag":"sourcefile","title":"FastVision/src/models.jl","docid":"sourcefiles/FastVision/src/models.jl"},{"tag":"sourcefile","title":"FastVision/src/models/unet.jl","docid":"sourcefiles/FastVision/src/models/unet.jl"},{"tag":"sourcefile","title":"FastVision/src/models/xresnet.jl","docid":"sourcefiles/FastVision/src/models/xresnet.jl"},{"tag":"sourcefile","title":"Flux/src/outputsize.jl","docid":"sourcefiles/Flux/src/outputsize.jl"},{"tag":"document","title":"Siamese image similarity","docid":"documents/docs/notebooks/siamese.ipynb"},{"tag":"documentation","title":"UNetDynamic","docid":"references/FastVision.Models.UNetDynamic"},{"tag":"document","title":"Keypoint regression","docid":"documents/docs/notebooks/keypointregression.ipynb"},{"tag":"document","title":"Custom learning tasks","docid":"documents/docs/learning_methods.md"}],"methods":[{"line":100,"file":"/home/runner/.julia/packages/Flux/KkC79/src/outputsize.jl","method_id":"Flux.outputsize_1","symbol_id":"Flux.outputsize","filedoc":"sourcefiles/Flux/src/outputsize.jl","signature":"outputsize(m::Chain, inputsizes::Tuple{Vararg{Integer}}...; padbatch)"},{"line":145,"file":"/home/runner/.julia/packages/Flux/KkC79/src/outputsize.jl","method_id":"Flux.outputsize_2","symbol_id":"Flux.outputsize","filedoc":"sourcefiles/Flux/src/outputsize.jl","signature":"outputsize(m::Tuple, input::Tuple...; padbatch)"},{"line":146,"file":"/home/runner/.julia/packages/Flux/KkC79/src/outputsize.jl","method_id":"Flux.outputsize_3","symbol_id":"Flux.outputsize","filedoc":"sourcefiles/Flux/src/outputsize.jl","signature":"outputsize(m::AbstractVector, input::Tuple...; padbatch)"},{"line":91,"file":"/home/runner/.julia/packages/Flux/KkC79/src/outputsize.jl","method_id":"Flux.outputsize_4","symbol_id":"Flux.outputsize","filedoc":"sourcefiles/Flux/src/outputsize.jl","signature":"outputsize(m, inputsizes::Tuple...; padbatch)"}],"name":"outputsize","title":"outputsize","symbol_id":"Flux.outputsize","public":false,"module_id":"Flux"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["outputsize(m, inputsize::Tuple; padbatch=false)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Calculate the size of the output from model ",{"attributes":{},"tag":"code","children":["m"],"type":"node"},", given the size of the input. Obeys ",{"attributes":{},"tag":"code","children":["outputsize(m, size(x)) == size(m(x))"],"type":"node"}," for valid input ",{"attributes":{},"tag":"code","children":["x"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["Keyword ",{"attributes":{},"tag":"code","children":["padbatch=true"],"type":"node"}," is equivalent to using ",{"attributes":{},"tag":"code","children":["(inputsize..., 1)"],"type":"node"},", and returns the final size including this extra batch dimension."],"type":"node"},{"attributes":{},"tag":"p","children":["This should be faster than calling ",{"attributes":{},"tag":"code","children":["size(m(x))"],"type":"node"},". It uses a trivial number type, which should work out of the box for custom layers."],"type":"node"},{"attributes":{},"tag":"p","children":["If ",{"attributes":{},"tag":"code","children":["m"],"type":"node"}," is a ",{"attributes":{},"tag":"code","children":["Tuple"],"type":"node"}," or ",{"attributes":{},"tag":"code","children":["Vector"],"type":"node"},", its elements are applied in sequence, like ",{"attributes":{},"tag":"code","children":["Chain(m...)"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"h1","children":["Examples"],"type":"node"},{"attributes":{"lang":"julia-repl"},"tag":"codeblock","children":["julia> using Flux: outputsize\n\njulia> outputsize(Dense(10, 4), (10,); padbatch=true)\n(4, 1)\n\njulia> m = Chain(Conv((3, 3), 3 => 16), Conv((3, 3), 16 => 32));\n\njulia> m(randn(Float32, 10, 10, 3, 64)) |> size\n(6, 6, 32, 64)\n\njulia> outputsize(m, (10, 10, 3); padbatch=true)\n(6, 6, 32, 1)\n\njulia> outputsize(m, (10, 10, 3, 64))\n(6, 6, 32, 64)\n\njulia> try outputsize(m, (10, 10, 7, 64)) catch e println(e) end\n┌ Error: layer Conv((3, 3), 3=>16), index 1 in Chain, gave an error with input of size (10, 10, 7, 64)\n└ @ Flux ~/.julia/dev/Flux/src/outputsize.jl:114\nDimensionMismatch(\"Input channels must match! (7 vs. 3)\")\n\njulia> outputsize([Dense(10, 4), Dense(4, 2)], (10, 1)) # Vector of layers becomes a Chain\n(2, 1)\n"],"type":"node"},{"attributes":{},"tag":"hr","children":[],"type":"node"},{"attributes":{"lang":""},"tag":"codeblock","children":["outputsize(m, x_size, y_size, ...; padbatch=false)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["For model or layer ",{"attributes":{},"tag":"code","children":["m"],"type":"node"}," accepting multiple arrays as input, this returns ",{"attributes":{},"tag":"code","children":["size(m((x, y, ...)))"],"type":"node"}," given ",{"attributes":{},"tag":"code","children":["size_x = size(x)"],"type":"node"},", etc."],"type":"node"},{"attributes":{},"tag":"h1","children":["Examples"],"type":"node"},{"attributes":{"lang":"jldoctest"},"tag":"codeblock","children":["julia> x, y = rand(Float32, 5, 64), rand(Float32, 7, 64);\n\njulia> par = Parallel(vcat, Dense(5, 9), Dense(7, 11));\n\njulia> Flux.outputsize(par, (5, 64), (7, 64))\n(20, 64)\n\njulia> m = Chain(par, Dense(20, 13), softmax);\n\njulia> Flux.outputsize(m, (5,), (7,); padbatch=true)\n(13, 1)\n\njulia> par(x, y) == par((x, y)) == Chain(par, identity)((x, y))\ntrue\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Notice that ",{"attributes":{},"tag":"code","children":["Chain"],"type":"node"}," only accepts multiple arrays as a tuple, while ",{"attributes":{},"tag":"code","children":["Parallel"],"type":"node"}," also accepts them as multiple arguments; ",{"attributes":{},"tag":"code","children":["outputsize"],"type":"node"}," always supplies the tuple."],"type":"node"}],"type":"node"}],"type":"node"}