{"attributes":{"kind":"function","backlinks":[{"tag":"sourcefile","title":"MLUtils/folds.jl","docid":"MLUtils@0.2.11/src/folds.jl"},{"tag":"sourcefile","title":"MLUtils/MLUtils.jl","docid":"MLUtils@0.2.11/src/MLUtils.jl"},{"tag":"documentation","title":"kfolds","docid":"MLUtils@0.2.11/ref/MLUtils.kfolds"}],"methods":[{"symbol_id":"MLUtils.leavepout","module_id":"MLUtils","file":"folds.jl","line":155,"signature":"(::Signature)"},{"symbol_id":"MLUtils.leavepout","module_id":"MLUtils","file":"folds.jl","line":190,"signature":"(::Signature)"},{"symbol_id":"MLUtils.leavepout","module_id":"MLUtils","file":"folds.jl","line":183,"signature":"(::Signature)"}],"package_id":"MLUtils@0.2.11","title":"leavepout","symbol_id":"MLUtils.leavepout","exported":true,"module_id":"MLUtils"},"tag":"documentation","children":[{"attributes":{"symbol":"MLUtils.leavepout","line":116,"module":"MLUtils","file":"folds.jl"},"tag":"docstring","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["leavepout(n::Integer, [size = 1]) -> Tuple\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Compute the train/validation assignments for ",{"attributes":{},"tag":"code","children":["k â‰ˆ n/size"],"type":"node"}," repartitions of ",{"attributes":{},"tag":"code","children":["n"],"type":"node"}," observations, and return them in the form of two vectors. The first vector contains the index-vectors for the training subsets, and the second vector the index-vectors for the validation subsets respectively. Each validation subset will have either ",{"attributes":{},"tag":"code","children":["size"],"type":"node"}," or ",{"attributes":{},"tag":"code","children":["size+1"],"type":"node"}," observations assigned to it. The following code snippet generates the index-vectors for ",{"attributes":{},"tag":"code","children":["size = 2"],"type":"node"},"."],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"toplevel","children":[{"attributes":{},"tag":"=","children":[{"attributes":{},"tag":"tuple","children":[{"attributes":{},"tag":"call","children":[{"attributes":{},"tag":"Identifier","children":["julia"],"type":"node"},{"attributes":{},"tag":">","children":[">"],"type":"node"},{"attributes":{},"tag":"Whitespace","children":[" "],"type":"node"},{"attributes":{},"tag":"Identifier","children":["train_idx"],"type":"node"}],"type":"node"},{"attributes":{},"tag":",","children":[","],"type":"node"},{"attributes":{},"tag":"Whitespace","children":[" "],"type":"node"},{"attributes":{},"tag":"Identifier","children":["val_idx"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"Whitespace","children":[" "],"type":"node"},{"attributes":{},"tag":"=","children":["="],"type":"node"},{"attributes":{},"tag":"Whitespace","children":[" "],"type":"node"},{"attributes":{},"tag":"call","children":[{"attributes":{"reftype":"symbol","document_id":"MLUtils@0.2.11/ref/MLUtils.leavepout"},"tag":"reference","children":["leavepout"],"type":"node"},{"attributes":{},"tag":"(","children":["("],"type":"node"},{"attributes":{},"tag":"Integer","children":["10"],"type":"node"},{"attributes":{},"tag":",","children":[","],"type":"node"},{"attributes":{},"tag":"Whitespace","children":[" "],"type":"node"},{"attributes":{},"tag":"Integer","children":["2"],"type":"node"},{"attributes":{},"tag":")","children":[")"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":";","children":[";"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Each observation is assigned to the validation subset once (and only once). Thus, a union over all validation index-vectors reproduces the full range ",{"attributes":{},"tag":"code","children":["1:n"],"type":"node"},". Note that there is no random assignment of observations to subsets, which means that adjacent observations are likely to be part of the same validation subset."],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":["julia> train_idx\n5-element Array{Array{Int64,1},1}:\n [3,4,5,6,7,8,9,10]\n [1,2,5,6,7,8,9,10]\n [1,2,3,4,7,8,9,10]\n [1,2,3,4,5,6,9,10]\n [1,2,3,4,5,6,7,8]\n\njulia> val_idx\n5-element Array{UnitRange{Int64},1}:\n 1:2\n 3:4\n 5:6\n 7:8\n 9:10"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{"symbol":"MLUtils.leavepout","line":161,"module":"MLUtils","file":"folds.jl"},"tag":"docstring","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["leavepout(data, p = 1)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Repartition a ",{"attributes":{},"tag":"code","children":["data"],"type":"node"}," container using a k-fold strategy, where ",{"attributes":{},"tag":"code","children":["k"],"type":"node"}," is chosen in such a way, that each validation subset of the resulting folds contains roughly ",{"attributes":{},"tag":"code","children":["p"],"type":"node"}," observations. Defaults to ",{"attributes":{},"tag":"code","children":["p = 1"],"type":"node"},", which is also known as \"leave-one-out\" partitioning."],"type":"node"},{"attributes":{},"tag":"p","children":["The resulting sequence of folds is returned as a lazy iterator. Only data subsets are created. That means no actual data is copied until ",{"attributes":{"reftype":"symbol","href":"@ref","title":"","document_id":"MLUtils@0.2.11/ref/MLUtils.getobs"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["getobs"],"type":"node"}],"type":"node"}," is invoked."],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"for","children":[{"attributes":{},"tag":"for","children":["for"],"type":"node"},{"attributes":{},"tag":"=","children":[{"attributes":{},"tag":"Whitespace","children":[" "],"type":"node"},{"attributes":{},"tag":"tuple","children":[{"attributes":{},"tag":"(","children":["("],"type":"node"},{"attributes":{},"tag":"Identifier","children":["train"],"type":"node"},{"attributes":{},"tag":",","children":[","],"type":"node"},{"attributes":{},"tag":"Whitespace","children":[" "],"type":"node"},{"attributes":{},"tag":"Identifier","children":["val"],"type":"node"},{"attributes":{},"tag":")","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"Whitespace","children":[" "],"type":"node"},{"attributes":{},"tag":"in","children":["in"],"type":"node"},{"attributes":{},"tag":"Whitespace","children":[" "],"type":"node"},{"attributes":{},"tag":"call","children":[{"attributes":{"reftype":"symbol","document_id":"MLUtils@0.2.11/ref/MLUtils.leavepout"},"tag":"reference","children":["leavepout"],"type":"node"},{"attributes":{},"tag":"(","children":["("],"type":"node"},{"attributes":{},"tag":"Identifier","children":["X"],"type":"node"},{"attributes":{},"tag":",","children":[","],"type":"node"},{"attributes":{},"tag":"Whitespace","children":[" "],"type":"node"},{"attributes":{},"tag":"kw","children":[{"attributes":{},"tag":"Identifier","children":["p"],"type":"node"},{"attributes":{},"tag":"=","children":["="],"type":"node"},{"attributes":{},"tag":"Integer","children":["2"],"type":"node"}],"type":"node"},{"attributes":{},"tag":")","children":[")"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"block","children":[{"attributes":{},"tag":"NewlineWs","children":["\n    "],"type":"node"},{"attributes":{},"tag":"Comment","children":["# if nobs(X) is dividable by 2,"],"type":"node"},{"attributes":{},"tag":"NewlineWs","children":["\n    "],"type":"node"},{"attributes":{},"tag":"Comment","children":["# then numobs(val) will be 2 for each iteraton,"],"type":"node"},{"attributes":{},"tag":"NewlineWs","children":["\n    "],"type":"node"},{"attributes":{},"tag":"Comment","children":["# otherwise it may be 3 for the first few iterations."],"type":"node"},{"attributes":{},"tag":"NewlineWs","children":["\n"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"end","children":["end"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["See",{"attributes":{"reftype":"symbol","href":"@ref","title":"","document_id":"MLUtils@0.2.11/ref/MLUtils.kfolds"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["kfolds"],"type":"node"}],"type":"node"}," for a related function."],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}