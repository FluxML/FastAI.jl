{"attributes":{"kind":"struct","backlinks":[{"tag":"documentation","title":"EarlyStopping","docid":"FluxTraining@0.3.9/ref/FluxTraining.EarlyStopping"},{"tag":"documentation","title":"LogTraces","docid":"FluxTraining@0.3.9/ref/FluxTraining.LogTraces"},{"tag":"sourcefile","title":"FastAI/training/onecycle.jl","docid":"FastAI@dev/src/training/onecycle.jl"},{"tag":"documentation","title":"MetricsPrinter","docid":"FluxTraining@0.3.9/ref/FluxTraining.MetricsPrinter"},{"tag":"document","title":"Introduction","docid":"FastAI@dev/doc/docs/introduction.md"},{"tag":"sourcefile","title":"FluxTraining/FluxTraining.jl","docid":"FluxTraining@0.3.9/src/FluxTraining.jl"},{"tag":"sourcefile","title":"FastAI/FastAI.jl","docid":"FastAI@dev/src/FastAI.jl"},{"tag":"document","title":"fastai API comparison","docid":"FastAI@dev/doc/docs/fastai_api_comparison.md"},{"tag":"document","title":"Custom learning tasks","docid":"FastAI@dev/doc/docs/learning_methods.md"},{"tag":"documentation","title":"StopOnNaNLoss","docid":"FluxTraining@0.3.9/ref/FluxTraining.StopOnNaNLoss"},{"tag":"sourcefile","title":"FastAI/learner.jl","docid":"FastAI@dev/src/learner.jl"},{"tag":"document","title":"Tabular Classification","docid":"FastAI@dev/doc/docs/notebooks/tabularclassification.ipynb"},{"tag":"document","title":"Keypoint regression","docid":"FastAI@dev/doc/docs/notebooks/keypointregression.ipynb"},{"tag":"document","title":"TimeSeries Classification","docid":"FastAI@dev/doc/docs/notebooks/timeseriesclassification.ipynb"},{"tag":"documentation","title":"Metrics","docid":"FluxTraining@0.3.9/ref/FluxTraining.Metrics"},{"tag":"document","title":"Image segmentation","docid":"FastAI@dev/doc/docs/notebooks/imagesegmentation.ipynb"},{"tag":"document","title":"Siamese image similarity","docid":"FastAI@dev/doc/docs/notebooks/siamese.ipynb"},{"tag":"documentation","title":"Traces","docid":"FluxTraining@0.3.9/ref/FluxTraining.Traces"},{"tag":"documentation","title":"Callback","docid":"FluxTraining@0.3.9/ref/FluxTraining.Callback"},{"tag":"document","title":"Variational autoencoders","docid":"FastAI@dev/doc/docs/notebooks/vae.ipynb"},{"tag":"document","title":"tsregression","docid":"FastAI@dev/doc/docs/notebooks/tsregression.ipynb"},{"tag":"sourcefile","title":"FluxTraining/learner.jl","docid":"FluxTraining@0.3.9/src/learner.jl"},{"tag":"sourcefile","title":"FluxTraining/testutils.jl","docid":"FluxTraining@0.3.9/src/testutils.jl"},{"tag":"sourcefile","title":"FastAI/interpretation/learner.jl","docid":"FastAI@dev/src/interpretation/learner.jl"},{"tag":"documentation","title":"LogMetrics","docid":"FluxTraining@0.3.9/ref/FluxTraining.LogMetrics"},{"tag":"documentation","title":"tasklearner","docid":"FastAI@dev/ref/FastAI.tasklearner"},{"tag":"documentation","title":"testlearner","docid":"FluxTraining@0.3.9/ref/FluxTraining.testlearner"}],"methods":[{"symbol_id":"FluxTraining.Learner","module_id":"FluxTraining","file":"learner.jl","line":15,"signature":"(::Signature)"},{"symbol_id":"FluxTraining.Learner","module_id":"FluxTraining","file":"learner.jl","line":72,"signature":"(::Signature)"},{"symbol_id":"FluxTraining.Learner","module_id":"FluxTraining","file":"learner.jl","line":81,"signature":"(::Signature)"}],"package_id":"FluxTraining@0.3.9","title":"Learner","symbol_id":"FluxTraining.Learner","exported":true,"module_id":"FluxTraining"},"tag":"documentation","children":[{"attributes":{"symbol":"FluxTraining.Learner","line":28,"module":"FluxTraining","file":"learner.jl"},"tag":"docstring","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["Learner(model, lossfn; [callbacks = [], optimizer = ADAM(), kwargs...])\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Holds and coordinates all state of the training. ",{"attributes":{},"tag":"code","children":["model"],"type":"node"}," is trained by optimizing ",{"attributes":{},"tag":"code","children":["lossfn"],"type":"node"}," with ",{"attributes":{},"tag":"code","children":["optimizer"],"type":"node"}," on ",{"attributes":{},"tag":"code","children":["data"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"h2","children":["Arguments"],"type":"node"},{"attributes":{},"tag":"p","children":["Positional arguments:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["model"],"type":"node"},": A Flux.jl model or a ",{"attributes":{},"tag":"code","children":["NamedTuple"],"type":"node"}," of models."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["lossfn"],"type":"node"},": Loss function with signature ",{"attributes":{},"tag":"code","children":["lossfn(model(x), y) -> Number"],"type":"node"},"."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Keyword arguments (optional):"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["data = ()"],"type":"node"},": Data iterators. A 2-tuple will be treated as ",{"attributes":{},"tag":"code","children":["(trainingdataiter, validdataiter)"],"type":"node"},". You can also pass in an empty tuple ",{"attributes":{},"tag":"code","children":["()"],"type":"node"}," and use the ",{"attributes":{"reftype":"symbol","href":"#","title":"","document_id":"FluxTraining@0.3.9/ref/FluxTraining.epoch!"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["epoch!"],"type":"node"}],"type":"node"}," method with a ",{"attributes":{},"tag":"code","children":["dataiter"],"type":"node"}," as third argument."],"type":"node"},{"attributes":{},"tag":"p","children":["A data iterator is an iterable over batches. For regular supervised training, each batch should be a tuple ",{"attributes":{},"tag":"code","children":["(xs, ys)"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["optimizer = ADAM()"],"type":"node"},": The optimizer used to update the ",{"attributes":{},"tag":"code","children":["model"],"type":"node"},"'s weights"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["callbacks = []"],"type":"node"},": A list of callbacks that should be used. If ",{"attributes":{},"tag":"code","children":["usedefaultcallbacks == true"],"type":"node"},", this will be extended by the default callbacks"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["usedefaultcallbacks = true"],"type":"node"},": Whether to add some basic callbacks. Included are ",{"attributes":{"reftype":"symbol","href":"#","title":"","document_id":"FluxTraining@0.3.9/ref/FluxTraining.Metrics"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["Metrics"],"type":"node"}],"type":"node"},", ",{"attributes":{"reftype":"symbol","href":"#","title":"","document_id":"FluxTraining@0.3.9/ref/FluxTraining.Recorder"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["Recorder"],"type":"node"}],"type":"node"},", ",{"attributes":{"reftype":"symbol","href":"#","title":"","document_id":"FluxTraining@0.3.9/ref/FluxTraining.ProgressPrinter"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["ProgressPrinter"],"type":"node"}],"type":"node"},", ",{"attributes":{"reftype":"symbol","href":"#","title":"","document_id":"FluxTraining@0.3.9/ref/FluxTraining.StopOnNaNLoss"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["StopOnNaNLoss"],"type":"node"}],"type":"node"},", and ",{"attributes":{"reftype":"symbol","href":"#","title":"","document_id":"FluxTraining@0.3.9/ref/FluxTraining.MetricsPrinter"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["MetricsPrinter"],"type":"node"}],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["cbrunner = LinearRunner()"],"type":"node"},": Callback runner to use."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Fields"],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"em","children":["(Use this as a reference when implementing callbacks)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["model"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["optimizer"],"type":"node"},", and ",{"attributes":{},"tag":"code","children":["lossfn"],"type":"node"}," are stored as passed in"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["data"],"type":"node"}," is a ",{"attributes":{},"tag":"code","children":["PropDict"],"type":"node"}," of data iterators, usually ",{"attributes":{},"tag":"code","children":[":training"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":[":validation"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["params"],"type":"node"},": An instance of ",{"attributes":{},"tag":"code","children":["model"],"type":"node"},"'s parameters of type ",{"attributes":{},"tag":"code","children":["Flux.Params"],"type":"node"},". If ",{"attributes":{},"tag":"code","children":["model"],"type":"node"}," is a ",{"attributes":{},"tag":"code","children":["NamedTuple"],"type":"node"},", then ",{"attributes":{},"tag":"code","children":["params"],"type":"node"}," is a ",{"attributes":{},"tag":"code","children":["NamedTuple"],"type":"node"}," as well."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["step::"],"type":"node"},{"attributes":{"reftype":"symbol","href":"#","title":"","document_id":"FluxTraining@0.3.9/ref/FluxTraining.PropDict"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["PropDict"],"type":"node"}],"type":"node"},": State of the last step. Contents depend on the last run ",{"attributes":{"href":"#","title":""},"tag":"a","children":[{"attributes":{},"tag":"code","children":["Phase"],"type":"node"}],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["cbstate::"],"type":"node"},{"attributes":{"reftype":"symbol","href":"#","title":"","document_id":"FluxTraining@0.3.9/ref/FluxTraining.PropDict"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["PropDict"],"type":"node"}],"type":"node"},": Special state container that callbacks can save state to for other callbacks. Its keys depend on what callbacks are being used. See the ",{"attributes":{"href":"/docs/docs/callbacks/custom.md","title":"","document_id":"FluxTraining@0.3.9/ref/docs/docs/callbacks/custom.md"},"tag":"reference","children":["custom callbacks guide"],"type":"node"}," for more info."],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{"symbol":"FluxTraining.Learner","line":78,"module":"FluxTraining","file":"learner.jl"},"tag":"docstring","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["Learner(model, data, optimizer, lossfn, [callbacks...; kwargs...])\n"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}